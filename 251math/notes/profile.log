FUNCTION  <SNR>140_indent_envs()
    Defined: ~/.vim/plugged/vimtex/indent/tex.vim line 175
Called 1 time
Total time:   0.000117
 Self time:   0.000117

count  total (s)   self (s)
    1              0.000005   let l:ind = 0
                            
                              " First for general environments
    1              0.000027   let l:ind += s:sw*(    a:prev =~# s:envs_begin && a:prev !~# s:envs_end && a:prev !~# s:envs_ignored)
    1              0.000022   let l:ind -= s:sw*(    a:cur !~# s:envs_begin && a:cur =~# s:envs_end && a:cur !~# s:envs_ignored)
                            
                              " Indentation for prolonged items in lists
    1              0.000017   let l:ind += s:sw*((a:prev =~# s:envs_item)    && (a:cur  !~# s:envs_enditem))
    1              0.000013   let l:ind -= s:sw*((a:cur  =~# s:envs_item)    && (a:prev !~# s:envs_begitem))
    1              0.000021   let l:ind -= s:sw*((a:cur  =~# s:envs_endlist) && (a:prev !~# s:envs_begitem))
                            
    1              0.000004   return l:ind

FUNCTION  airline#extensions#wordcount#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/wordcount.vim line 74
Called 105 times
Total time:   0.002675
 Self time:   0.001933

count  total (s)   self (s)
  105              0.000346   if get(g:, 'airline#visual_active', 0)
                                return s:format_wordcount(s:get_wordcount(1))
  105              0.000062   else
  105              0.000304     if get(b:, 'airline_changedtick', 0) != b:changedtick
    7   0.000796   0.000054       call s:update_wordcount(0)
    7              0.000015       let b:airline_changedtick = b:changedtick
  105              0.000055     endif
  105              0.000272     return get(b:, 'airline_wordcount', '')
                              endif

FUNCTION  gitgutter#process_buffer()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim line 21
Called 9 times
Total time:   0.044865
 Self time:   0.001421

count  total (s)   self (s)
                              " NOTE a:bufnr is not necessarily the current buffer.
                            
    9   0.005240   0.000268   if gitgutter#utility#is_active(a:bufnr)
                            
    9              0.000129     if has('patch-7.4.1559')
    9              0.000238       let l:Callback = function('gitgutter#process_buffer', [a:bufnr, a:force])
                                else
                                  let l:Callback = {'function': 'gitgutter#process_buffer', 'arguments': [a:bufnr, a:force]}
    9              0.000013     endif
    9   0.038864   0.000393     let how = s:setup_path(a:bufnr, l:Callback)
    9              0.000153     if [how] == ['async']  " avoid string-to-number conversion if how is a number
    9              0.000024       return
                                endif
                            
                                if a:force || s:has_fresh_changes(a:bufnr)
                            
                                  let diff = 'NOT SET'
                                  try
                                    let diff = gitgutter#diff#run_diff(a:bufnr, g:gitgutter_diff_relative_to, 0)
                                  catch /gitgutter not tracked/
                                    call gitgutter#debug#log('Not tracked: '.gitgutter#utility#file(a:bufnr))
                                  catch /gitgutter diff failed/
                                    call gitgutter#debug#log('Diff failed: '.gitgutter#utility#file(a:bufnr))
                                    call gitgutter#hunk#reset(a:bufnr)
                                  endtry
                            
                                  if diff != 'async' && diff != 'NOT SET'
                                    call gitgutter#diff#handler(a:bufnr, diff)
                                  endif
                            
                                endif
                              endif

FUNCTION  <SNR>191_AutoUpdate()
    Defined: ~/.vim/plugged/tagbar/autoload/tagbar.vim line 2616
Called 5 times
Total time:   0.009422
 Self time:   0.003913

count  total (s)   self (s)
    5   0.000316   0.000169     call tagbar#debug#log('AutoUpdate called [' . a:fname . ']')
                            
                                " Whether we want to skip actually displaying the tags in Tagbar and only
                                " update the fileinfo
    5              0.000045     let no_display = a:0 > 0 ? a:1 : 0
                            
                                " This file is being loaded due to a quickfix command like vimgrep, so
                                " don't process it
    5              0.000036     if exists('s:tagbar_qf_active')
                                    return
    5              0.000031     elseif exists('s:window_opening')
                                    " This can happen if another plugin causes the active window to change
                                    " with an autocmd during the initial Tagbar window creation. In that
                                    " case InitWindow() hasn't had a chance to run yet and things can
                                    " break. MiniBufExplorer does this, for example. Completely disabling
                                    " autocmds at that point is also not ideal since for example
                                    " statusline plugins won't be able to update.
                                    call tagbar#debug#log('Still opening window, stopping processing')
                                    return
    5              0.000008     endif
                            
                                " Get the filetype of the file we're about to process
    5              0.000295     let bufnr = bufnr(a:fname)
    5              0.000062     let ftype = getbufvar(bufnr, '&filetype')
                            
                                " Don't do anything if we're in the tagbar window
    5              0.000025     if ftype ==# 'tagbar'
                                    call tagbar#debug#log('In Tagbar window, stopping processing')
                                    return
    5              0.000007     endif
                            
                                " Only consider the main filetype in cases like 'python.django'
    5              0.000172     let sftype = get(split(ftype, '\.'), 0, '')
    5   0.000279   0.000167     call tagbar#debug#log("Vim filetype: '" . ftype . "', " . "sanitized filetype: '" . sftype . "'")
                            
                                " Don't do anything if the file isn't supported
    5   0.001372   0.000140     if !s:IsValidFile(a:fname, sftype)
                                    call tagbar#debug#log('Not a valid file, stopping processing')
                                    let s:nearby_disabled = 1
                                    return
    5              0.000007     endif
                            
    5              0.000023     let updated = 0
                            
                                " Process the file if it's unknown or the information is outdated.
                                " Testing the mtime of the file is necessary in case it got changed
                                " outside of Vim, for example by checking out a different version from a
                                " VCS.
    5   0.000202   0.000137     if s:known_files.has(a:fname)
    5   0.000156   0.000085         let curfile = s:known_files.get(a:fname)
                                    " if a:force || getbufvar(curfile.bufnr, '&modified') ||
    5              0.000214         if a:force || empty(curfile) || curfile.ftype != sftype || (filereadable(a:fname) && getftime(a:fname) > curfile.mtime)
                                        call tagbar#debug#log('File data outdated, updating [' . a:fname . ']')
                                        call s:ProcessFile(a:fname, sftype)
                                        let updated = 1
    5              0.000010         else
    5   0.000221   0.000119             call tagbar#debug#log('File data seems up to date [' . a:fname . ']')
    5              0.000009         endif
                                elseif !s:known_files.has(a:fname)
                                    call tagbar#debug#log('New file, processing [' . a:fname . ']')
                                    call s:ProcessFile(a:fname, sftype)
                                    let updated = 1
    5              0.000008     endif
                            
    5              0.000017     if no_display
                                    return
    5              0.000007     endif
                            
    5   0.000138   0.000086     let fileinfo = s:known_files.get(a:fname)
                            
                                " If we don't have an entry for the file by now something must have gone
                                " wrong, so don't change the tagbar content
    5              0.000027     if empty(fileinfo)
                                    call tagbar#debug#log('fileinfo empty after processing [' . a:fname . ']')
                                    return
    5              0.000007     endif
                            
                                " Display the tagbar content if the tags have been updated or a different
                                " file is being displayed
    5   0.000777   0.000649     if bufwinnr(s:TagbarBufName()) != -1 && !s:paused && (s:new_window || updated || (!empty(tagbar#state#get_current_file(0)) && a:fname != tagbar#state#get_current_file(0).fpath))
                                    call s:RenderContent(fileinfo)
    5              0.000008     endif
                            
                                " Call setCurrent after rendering so RenderContent can check whether the
                                " same file is being redisplayed
    5              0.000028     if !empty(fileinfo)
    5   0.000236   0.000138         call tagbar#debug#log('Setting current file [' . a:fname . ']')
    5   0.000533   0.000115         call tagbar#state#set_current_file(fileinfo)
    5              0.000028         let s:nearby_disabled = 0
    5              0.000008     endif
                            
    5   0.002584   0.000129     call s:HighlightTag(0)
    5   0.000650   0.000109     call s:SetStatusLine()
    5   0.000183   0.000096     call tagbar#debug#log('AutoUpdate finished successfully')

FUNCTION  <SNR>66_dir()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim line 198
Called 18 times
Total time:   0.003021
 Self time:   0.000797

count  total (s)   self (s)
   18   0.003002   0.000778   return gitgutter#utility#shellescape(fnamemodify(s:abs_path(a:bufnr, 0), ':h'))

FUNCTION  <SNR>36_AsyncRequest()
    Defined: ~/.vim/plugged/coc.nvim/plugin/coc.vim line 50
Called 5 times
Total time:   0.001778
 Self time:   0.000444

count  total (s)   self (s)
    5              0.000101   let Cb = a:args[len(a:args) - 1]
    5              0.000044   if type(Cb) == 2
                                if !coc#rpc#ready()
                                  call Cb('service not started', v:null)
                                else
                                  call coc#rpc#request_async(a:name, a:args[0:-2], Cb)
                                endif
                                return ''
    5              0.000009   endif
    5   0.001457   0.000123   call coc#rpc#notify(a:name, a:args)
    5              0.000010   return ''

FUNCTION  airline#extensions#coc#get_error()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/coc.vim line 14
Called 105 times
Total time:   0.003193
 Self time:   0.000792

count  total (s)   self (s)
  105   0.003145   0.000745   return airline#extensions#coc#get('error')

FUNCTION  <SNR>66_not_git_dir()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim line 65
Called 9 times
Total time:   0.002018
 Self time:   0.000414

count  total (s)   self (s)
    9   0.002009   0.000406   return s:dir(a:bufnr) !~ '[/\\]\.git\($\|[/\\]\)'

FUNCTION  UltiSnips#CursorMoved()
    Defined: ~/.vim/plugged/ultisnips/autoload/UltiSnips.vim line 134
Called 16 times
Total time:   0.077091
 Self time:   0.077091

count  total (s)   self (s)
   16              0.077078     py3 UltiSnips_Manager._cursor_moved()

FUNCTION  <SNR>166_ws_refresh()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim line 183
Called 5 times
Total time:   0.000228
 Self time:   0.000228

count  total (s)   self (s)
    5              0.000114   if get(b:, 'airline_ws_changedtick', 0) == b:changedtick
    3              0.000009     return
    2              0.000004   endif
    2              0.000022   unlet! b:airline_whitespace_check
    2              0.000014   if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh!'
    2              0.000003   endif
    2              0.000018   let b:airline_ws_changedtick = b:changedtick

FUNCTION  <SNR>74_Highlight_Matching_Pair()
    Defined: /usr/share/nvim/runtime/plugin/matchparen.vim line 39
Called 22 times
Total time:   0.012081
 Self time:   0.012081

count  total (s)   self (s)
                              " Remove any previous match.
   22              0.000105   if exists('w:paren_hl_on') && w:paren_hl_on
   12              0.000055     silent! call matchdelete(3)
   12              0.000028     let w:paren_hl_on = 0
   22              0.000016   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
   22              0.000109   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
   22              0.000013   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
   22              0.000067   let c_lnum = line('.')
   22              0.000058   let c_col = col('.')
   22              0.000050   let before = 0
                            
   22              0.000076   let text = getline(c_lnum)
   22              0.000455   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
   22              0.000055   if empty(matches)
                                let [c_before, c] = ['', '']
   22              0.000021   else
   22              0.000126     let [c_before, c] = matches[1:2]
   22              0.000016   endif
   22              0.000370   let plist = split(&matchpairs, '.\zs[:,]')
   22              0.000186   let i = index(plist, c)
   22              0.000035   if i < 0
                                " not found, in Insert mode try character before the cursor
    9              0.000049     if c_col > 1 && (mode() == 'i' || mode() == 'R')
    4              0.000012       let before = strlen(c_before)
    4              0.000006       let c = c_before
    4              0.000010       let i = index(plist, c)
    9              0.000007     endif
    9              0.000012     if i < 0
                                  " not found, nothing to do
    9              0.000011       return
                                endif
   13              0.000007   endif
                            
                              " Figure out the arguments for searchpairpos().
   13              0.000019   if i % 2 == 0
    9              0.000015     let s_flags = 'nW'
    9              0.000025     let c2 = plist[i + 1]
    4              0.000002   else
    4              0.000007     let s_flags = 'nbW'
    4              0.000007     let c2 = c
    4              0.000011     let c = plist[i - 1]
   13              0.000008   endif
   13              0.000018   if c == '['
                                let c = '\['
                                let c2 = '\]'
   13              0.000007   endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
   13              0.000018   if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
   13              0.000006   endif
                            
   13              0.000102   if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
   13              0.000008   else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial.
   13              0.000065     let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
   13              0.000013     try
   13              0.004005       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
   13              0.000013     endtry
   13              0.000008   endif
                            
                              " Limit the search to lines visible in the window.
   13              0.000046   let stoplinebottom = line('w$')
   13              0.000042   let stoplinetop = line('w0')
   13              0.000022   if i % 2 == 0
    9              0.000026     let stopline = stoplinebottom
    4              0.000003   else
    4              0.000010     let stopline = stoplinetop
   13              0.000007   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
   13              0.000047   if mode() == 'i' || mode() == 'R'
    2              0.000007     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
   11              0.000007   else
   11              0.000059     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
   13              0.000008   endif
   13              0.000011   try
   13              0.003125     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
   13              0.000013   endtry
                            
   13              0.000020   if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
   13              0.000007   endif
                            
                              " If a match is found setup match highlighting.
   13              0.000044   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
   13              0.000039     if exists('*matchaddpos')
   13              0.000452       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
   13              0.000007     endif
   13              0.000038     let w:paren_hl_on = 1
   13              0.000009   endif

FUNCTION  coc#util#close_popup()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/util.vim line 132
Called 4 times
Total time:   0.000098
 Self time:   0.000098

count  total (s)   self (s)
    4              0.000006   if s:is_vim
                                if exists('*popup_close')
                                  call popup_close(get(g:, 'coc_popup_id', 0))
                                endif
    4              0.000002   else
    8              0.000023     for winnr in range(1, winnr('$'))
    4              0.000012       if getwinvar(winnr, 'popup', 0)
                                    exe winnr.'close!'
    4              0.000002       endif
    8              0.000007     endfor
    4              0.000003   endif

FUNCTION  <SNR>166_check_mixed_indent()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim line 15
Called 2 times
Total time:   0.003068
 Self time:   0.003068

count  total (s)   self (s)
    2              0.000020   let indent_algo = get(g:, 'airline#extensions#whitespace#mixed_indent_algo', 0)
    2              0.000008   if indent_algo == 1
                                " [<tab>]<space><tab>
                                " spaces before or between tabs are not allowed
                                let t_s_t = '(^\t* +\t\s*\S)'
                                " <tab>(<space> x count)
                                " count of spaces at the end of tabs should be less than tabstop value
                                let t_l_s = '(^\t+ {' . &ts . ',}' . '\S)'
                                return search('\v' . t_s_t . '|' . t_l_s, 'nw')
    2              0.000008   elseif indent_algo == 2
                                return search('\v(^\t* +\t\s*\S)', 'nw')
    2              0.000003   else
    2              0.002981     return search('\v(^\t+ +)|(^ +\t+)', 'nw')
                              endif

FUNCTION  coc#client#get_channel()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/client.vim line 98
Called 74 times
Total time:   0.000715
 Self time:   0.000715

count  total (s)   self (s)
   74              0.000169   if s:is_vim
                                return a:client['channel']
   74              0.000061   endif
   74              0.000206   return a:client['chan_id']

FUNCTION  <SNR>62_CursorHoldUpdate()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/nerdtree_plugin/git_status.vim line 263
Called 5 times
Total time:   0.000905
 Self time:   0.000190

count  total (s)   self (s)
    5              0.000031     if g:NERDTreeUpdateOnCursorHold != 1
                                    return
    5              0.000008     endif
                            
    5   0.000821   0.000107     if !g:NERDTree.IsOpen()
    5              0.000011         return
                                endif
                            
                                " Do not update when a special buffer is selected
                                if !empty(&l:buftype)
                                    return
                                endif
                            
                                let l:winnr = winnr()
                                let l:altwinnr = winnr('#')
                            
                                call g:NERDTree.CursorToTreeWin()
                                call b:NERDTree.root.refreshFlags()
                                call NERDTreeRender()
                            
                                exec l:altwinnr . 'wincmd w'
                                exec l:winnr . 'wincmd w'

FUNCTION  airline#extensions#tagbar#currenttag()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tagbar.vim line 32
Called 105 times
Total time:   0.006029
 Self time:   0.002932

count  total (s)   self (s)
  105              0.000278   if get(w:, 'airline_active', 0)
  105              0.000137     if !s:init
                                  try
                                    " try to load the plugin, if filetypes are disabled,
                                    " this will cause an error, so try only once
                                    let a=tagbar#currenttag('%', '', '')
                                  catch
                                  endtry
                                  unlet! a
                                  let s:init=1
  105              0.000061     endif
                                " function tagbar#currenttag does not exist, if filetype is not enabled
  105              0.000395     if s:airline_tagbar_last_lookup_time != localtime() && exists("*tagbar#currenttag")
   13   0.003242   0.000146       let s:airline_tagbar_last_lookup_val = tagbar#currenttag('%s', '', s:flags)
   13              0.000041       let s:airline_tagbar_last_lookup_time = localtime()
  105              0.000057     endif
  105              0.000234     return s:airline_tagbar_last_lookup_val
                              endif
                              return ''

FUNCTION  airline#statusline()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim line 190
Called 105 times
Total time:   0.002119
 Self time:   0.002119

count  total (s)   self (s)
  105              0.000941   if has_key(s:contexts, a:winnr)
  105              0.000973     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  airline#check_mode()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim line 199
Called 105 times
Total time:   0.314730
 Self time:   0.016293

count  total (s)   self (s)
  105              0.000545   if !has_key(s:contexts, a:winnr)
                                return ''
  105              0.000118   endif
  105              0.000432   let context = s:contexts[a:winnr]
                            
  105              0.000437   if get(w:, 'airline_active', 1)
  105              0.000385     let l:m = mode(1)
  105              0.000230     if l:m ==# "i"
   45              0.000136       let l:mode = ['insert']
   60              0.000150     elseif l:m[0] ==# "i"
   12              0.000035       let l:mode = ['insert']
   48              0.000071     elseif l:m ==# "Rv"
                                  let l:mode =['replace']
   48              0.000072     elseif l:m[0] ==# "R"
                                  let l:mode = ['replace']
   48              0.000502     elseif l:m[0] =~# '\v(v|V||s|S|)'
                                  let l:mode = ['visual']
   48              0.000064     elseif l:m ==# "t"
                                  let l:mode = ['terminal']
   48              0.000068     elseif l:m[0] ==# "c"
    2              0.000008       let l:mode = ['commandline']
   46              0.000065     elseif l:m ==# "no"   " does not work, most likely, Vim does not refresh the statusline in OP mode
                                  let l:mode = ['normal']
   46              0.000090     elseif l:m[0:1] ==# 'ni'
                                  let l:mode = ['normal']
                                  let l:m = 'ni'
   46              0.000032     else
   46              0.000120       let l:mode = ['normal']
  105              0.000076     endif
  105              0.000528     if exists("*VMInfos") && !empty(VMInfos())
                                  " Vim plugin Multiple Cursors https://github.com/mg979/vim-visual-multi
                                  let l:m = 'multi'
  105              0.000065     endif
  105              0.000754     if index(['Rv', 'no', 'ni', 'ix', 'ic', 'multi'], l:m) == -1
   93              0.000222       let l:m = l:m[0]
  105              0.000072     endif
  105              0.000574     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
                              else
                                let l:mode = ['inactive']
                                let w:airline_current_mode = get(g:airline_mode_map, '__')
  105              0.000082   endif
                            
  105              0.000393   if g:airline_detect_modified && &modified
  105              0.000420     call add(l:mode, 'modified')
  105              0.000077   endif
                            
  105              0.000241   if g:airline_detect_paste && &paste
                                call add(l:mode, 'paste')
  105              0.000067   endif
                            
  105              0.001174   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(l:mode, 'crypt')
  105              0.000063   endif
                            
  105              0.000256   if g:airline_detect_spell && &spell
                                call add(l:mode, 'spell')
  105              0.000057   endif
                            
  105              0.000239   if &readonly || ! &modifiable
                                call add(l:mode, 'readonly')
  105              0.000060   endif
                            
  105              0.000520   let mode_string = join(l:mode)
  105              0.000426   if get(w:, 'airline_lastmode', '') != mode_string
   18   0.009867   0.000379     call airline#highlighter#highlight_modified_inactive(context.bufnr)
   18   0.288247   0.000385     call airline#highlighter#highlight(l:mode, context.bufnr)
   18   0.001307   0.000220     call airline#util#doautocmd('AirlineModeChanged')
   18              0.000038     let w:airline_lastmode = mode_string
  105              0.000054   endif
                            
  105              0.000117   return ''

FUNCTION  <SNR>116_parser_delim_get_corr()
    Defined: ~/.vim/plugged/vimtex/autoload/vimtex/delim.vim line 779
Called 45 times
Total time:   0.003780
 Self time:   0.003780

count  total (s)   self (s)
   45              0.000123   let l:type = a:0 > 0 ? a:1 : 'delim_all'
                            
  540              0.000540   for l:pair in g:vimtex#delim#lists[l:type].name
  540              0.000797     if a:delim ==# l:pair[0]
   45              0.000059       return l:pair[1]
  495              0.000717     elseif a:delim ==# l:pair[1]
                                  return l:pair[0]
  495              0.000199     endif
  495              0.000224   endfor

FUNCTION  <SNR>162_group_not_done()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim line 25
Called 624 times
Total time:   0.004357
 Self time:   0.004357

count  total (s)   self (s)
  624              0.001615   if index(a:list, a:name) == -1
  432              0.001016     call add(a:list, a:name)
  432              0.000369     return 1
  192              0.000074   else
  192              0.000200     if &vbs
                                  echomsg printf("airline: group: %s already done, skipping", a:name)
  192              0.000068     endif
  192              0.000105     return 0
                              endif

FUNCTION  airline#util#append()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim line 49
Called 735 times
Total time:   0.007747
 Self time:   0.007747

count  total (s)   self (s)
  735              0.001915   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
  735              0.000366   endif
  735              0.002175   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
  735              0.002249   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  <SNR>191_TagbarBufName()
    Defined: ~/.vim/plugged/tagbar/autoload/tagbar.vim line 3363
Called 10 times
Total time:   0.000243
 Self time:   0.000243

count  total (s)   self (s)
   10              0.000095     if !exists('t:tagbar_buf_name')
                                    let s:buffer_seqno += 1
                                    let t:tagbar_buf_name = '__Tagbar__.' . s:buffer_seqno
   10              0.000014     endif
                            
   10              0.000041     return t:tagbar_buf_name

FUNCTION  <SNR>63_DevIconsGetArtifactFix()
    Defined: ~/.vim/plugged/vim-devicons/plugin/webdevicons.vim line 491
Called 222 times
Total time:   0.002037
 Self time:   0.002037

count  total (s)   self (s)
  222              0.000459   if g:DevIconsAppendArtifactFix == 1
                                let artifactFix = g:DevIconsArtifactFixChar
  222              0.000150   else
  222              0.000350     let artifactFix = ''
  222              0.000141   endif
                            
  222              0.000321   return artifactFix

FUNCTION  airline#themes#get_highlight()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/themes.vim line 31
Called 704 times
Total time:   0.065736
 Self time:   0.005980

count  total (s)   self (s)
  704   0.065559   0.005804   return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  airline#extensions#tabline#get_buffer_name()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline.vim line 201
Called 12 times
Total time:   0.008376
 Self time:   0.000887

count  total (s)   self (s)
   12   0.000497   0.000342   let buffers = a:0 ? a:1 : airline#extensions#tabline#buflist#list()
   12              0.000104   let formatter = get(g:, 'airline#extensions#tabline#formatter', 'default')
   12   0.007752   0.000418   return airline#extensions#tabline#formatters#{formatter}#format(a:nr, buffers)

FUNCTION  airline#mode_changed()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim line 279
Called 18 times
Total time:   0.000384
 Self time:   0.000290

count  total (s)   self (s)
                              " airline#visual_active
                              " Boolean: for when to get visual wordcount
                              " needed for the wordcount extension
   18              0.000158   let g:airline#visual_active = (mode() =~? '[vs]')
   18   0.000197   0.000104   call airline#update_tabline()

FUNCTION  vimtex#util#in_syntax()
    Defined: ~/.vim/plugged/vimtex/autoload/vimtex/util.vim line 60
Called 23 times
Total time:   0.004799
 Self time:   0.004799

count  total (s)   self (s)
                            
                              " Usage: vimtex#util#in_syntax(name, [line, col])
                            
                              " Get position and correct it if necessary
   23              0.000181   let l:pos = a:0 > 0 ? [a:1, a:2] : [line('.'), col('.')]
   23              0.000065   if mode() ==# 'i'
   11              0.000027     let l:pos[1] -= 1
   23              0.000017   endif
   23              0.000235   call map(l:pos, 'max([v:val, 1])')
                            
                              " Check syntax at position
   23              0.004124   return match(map(synstack(l:pos[0], l:pos[1]),          "synIDattr(v:val, 'name')"),      '^' . a:name) >= 0

FUNCTION  airline#extensions#vimtex#get_scope()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/vimtex.vim line 51
Called 105 times
Total time:   0.009851
 Self time:   0.006749

count  total (s)   self (s)
  105              0.000211   let l:status = ''
                            
  105              0.000412   let vt_local = get(b:, 'vimtex_local', {})
  105              0.000199   if empty(vt_local)
                                let l:status .= g:airline#extensions#vimtex#main
  105              0.000065   else
  105              0.000233     if get(vt_local, 'active')
                                  let l:status .= g:airline#extensions#vimtex#sub_local
  105              0.000063     else
  105              0.000363       let l:status .= g:airline#extensions#vimtex#sub_main
  105              0.000061     endif
  105              0.000051   endif
                            
  105              0.000589   if get(get(get(b:, 'vimtex', {}), 'viewer', {}), 'xwin_id')
                                let l:status .= g:airline#extensions#vimtex#viewer
  105              0.000056   endif
                            
  105              0.000464   let l:compiler = get(get(b:, 'vimtex', {}), 'compiler', {})
  105              0.000202   if !empty(l:compiler)
  105   0.004100   0.000998     if has_key(l:compiler, 'is_running') && b:vimtex.compiler.is_running()
                                  if get(l:compiler, 'continuous')
                                    let l:status .= g:airline#extensions#vimtex#continuous
                                  else
                                    let l:status .= g:airline#extensions#vimtex#compiled
                                  endif
  105              0.000056     endif
  105              0.000056   endif
                            
  105              0.000212   if !empty(l:status)
  105              0.000461     let l:status = g:airline#extensions#vimtex#left . l:status . g:airline#extensions#vimtex#right
  105              0.000057   endif
  105              0.000154   return l:status

FUNCTION  <SNR>191_SetStatusLine()
    Defined: ~/.vim/plugged/tagbar/autoload/tagbar.vim line 3158
Called 5 times
Total time:   0.000541
 Self time:   0.000427

count  total (s)   self (s)
    5   0.000500   0.000385     let tagbarwinnr = bufwinnr(s:TagbarBufName())
    5              0.000023     if tagbarwinnr == -1
    5              0.000010         return
                                endif
                            
                                " Make sure we're actually in the Tagbar window
                                if tagbarwinnr != winnr()
                                    let in_tagbar = 0
                                    let prevwinnr = winnr()
                                    call s:goto_win('p', 1)
                                    let pprevwinnr = winnr()
                                    call s:goto_win(tagbarwinnr, 1)
                                else
                                    let in_tagbar = 1
                                endif
                            
                                if !empty(tagbar#state#get_current_file(0))
                                    let fileinfo = tagbar#state#get_current_file(0)
                                    let fname = fnamemodify(fileinfo.fpath, ':t')
                                    let sorted = get(fileinfo.typeinfo, 'sort', g:tagbar_sort)
                                else
                                    let fname = ''
                                    let sorted = g:tagbar_sort
                                endif
                                let sortstr = sorted ? 'Name' : 'Order'
                            
                                let flags = []
                                let flags += exists('w:autoclose') && w:autoclose ? ['c'] : []
                                let flags += g:tagbar_autoclose ? ['C'] : []
                                let flags += (sorted && g:tagbar_case_insensitive) ? ['i'] : []
                                let flags += g:tagbar_hide_nonpublic ? ['v'] : []
                            
                                if exists('g:tagbar_status_func')
                                    let args = [in_tagbar, sortstr, fname, flags]
                                    let &l:statusline = call(g:tagbar_status_func, args)
                                else
                                    let colour = in_tagbar ? '%#StatusLine#' : '%#StatusLineNC#'
                                    let flagstr = join(flags, '')
                                    if flagstr !=# ''
                                        let flagstr = '[' . flagstr . '] '
                                    endif
                                    let text = colour . '[' . sortstr . '] ' . flagstr . fname
                                    let &l:statusline = text
                                endif
                            
                                if !in_tagbar
                                    call s:goto_win(pprevwinnr, 1)
                                    call s:goto_win(prevwinnr, 1)
                                endif

FUNCTION  <SNR>140_count()
    Defined: ~/.vim/plugged/vimtex/indent/tex.vim line 317
Called 4 times
Total time:   0.000549
 Self time:   0.000549

count  total (s)   self (s)
    4              0.000037   if empty(a:pattern) | return 0 | endif
                            
    4              0.000014   let l:sum = 0
    4              0.000188   let l:indx = match(a:line, a:pattern)
    6              0.000023   while l:indx >= 0
    2              0.000008     let l:sum += 1
    2              0.000082     let l:match = matchstr(a:line, a:pattern, l:indx)
    2              0.000015     let l:indx += len(l:match)
    2              0.000074     let l:indx = match(a:line, a:pattern, l:indx)
    6              0.000014   endwhile
    4              0.000013   return l:sum

FUNCTION  <SNR>162_GetHiCmd()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim line 164
Called 262 times
Total time:   0.017109
 Self time:   0.017109

count  total (s)   self (s)
                              " a:list needs to have 5 items!
  262              0.000276   let res = ''
  262              0.000272   let i = -1
 1572              0.001242   while i < 4
 1310              0.001269     let i += 1
 1310              0.002563     let item = get(a:list, i, '')
 1310              0.001182     if item is ''
  794              0.000506       continue
  516              0.000188     endif
  516              0.000377     if i == 0
                                  let res .= ' guifg='.item
  516              0.000385     elseif i == 1
                                  let res .= ' guibg='.item
  516              0.000429     elseif i == 2
  262              0.000583       let res .= ' ctermfg='.item
  254              0.000148     elseif i == 3
  196              0.000283       let res .= ' ctermbg='.item
   58              0.000036     elseif i == 4
   58              0.000233       let res .= printf(' gui=%s cterm=%s term=%s', item, item, item)
  516              0.000184     endif
  778              0.000551   endwhile
  262              0.000261   return res

FUNCTION  gitgutter#utility#set_repo_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim line 145
Called 9 times
Total time:   0.036088
 Self time:   0.002844

count  total (s)   self (s)
                              " Values of path:
                              " * non-empty string - path
                              " *               -1 - pending
                              " *               -2 - not tracked by git
                            
    9   0.000914   0.000269   call gitgutter#utility#setbufvar(a:bufnr, 'path', -1)
    9   0.009383   0.001044   let cmd = gitgutter#utility#cd_cmd(a:bufnr, g:gitgutter_git_executable.' '.g:gitgutter_git_args.' ls-files --error-unmatch --full-name -z -- '.gitgutter#utility#shellescape(s:filename(a:bufnr)))
                            
    9   0.000443   0.000373   if g:gitgutter_async && gitgutter#async#available() && !has('vim_starting')
    9              0.000115     let handler = copy(s:set_path_handler)
    9              0.000061     let handler.continuation = a:continuation
    9   0.024956   0.000766     call gitgutter#async#execute(cmd, a:bufnr, handler)
    9              0.000080     return 'async'
                              endif
                            
                              let path = gitgutter#utility#system(cmd)
                              if v:shell_error
                                call gitgutter#utility#setbufvar(a:bufnr, 'path', -2)
                              else
                                call gitgutter#utility#setbufvar(a:bufnr, 'path', s:strip_trailing_new_line(path))
                              endif

FUNCTION  VimtexIndent()
    Defined: ~/.vim/plugged/vimtex/indent/tex.vim line 35
Called 1 time
Total time:   0.002452
 Self time:   0.000447

count  total (s)   self (s)
    1              0.000024   let s:sw = exists('*shiftwidth') ? shiftwidth() : &shiftwidth
                            
    1   0.000373   0.000042   let [l:prev_lnum, l:prev_line] = s:get_prev_lnum(prevnonblank(a:lnum - 1))
    1              0.000012   if l:prev_lnum == 0 | return indent(a:lnum) | endif
    1   0.000063   0.000030   let l:line = s:clean_line(getline(a:lnum))
                            
                              " Check for verbatim modes
    1   0.000390   0.000056   if s:is_verbatim(l:line, a:lnum)
                                return empty(l:line) ? indent(l:prev_lnum) : indent(a:lnum)
    1              0.000003   endif
                            
                              " Use previous indentation for comments
    1              0.000030   if l:line =~# '^\s*%'
                                return indent(a:lnum)
    1              0.000002   endif
                            
                              " Align on ampersands
    1   0.000258   0.000066   let l:ind = s:indent_amps.check(a:lnum, l:line, l:prev_lnum, l:prev_line)
    1              0.000007   if s:indent_amps.finished | return l:ind | endif
    1              0.000006   let l:prev_lnum = s:indent_amps.prev_lnum
    1              0.000005   let l:prev_line = s:indent_amps.prev_line
                            
                              " Indent environments, delimiters, and tikz
    1   0.000145   0.000027   let l:ind += s:indent_envs(l:line, l:prev_line)
    1   0.000688   0.000028   let l:ind += s:indent_delims(l:line, a:lnum, l:prev_line, l:prev_lnum)
    1   0.000165   0.000031   let l:ind += s:indent_conditionals(l:line, a:lnum, l:prev_line, l:prev_lnum)
    1   0.000228   0.000025   let l:ind += s:indent_tikz(l:prev_lnum, l:prev_line)
                            
    1              0.000003   return l:ind

FUNCTION  <SNR>172_map_keys()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buffers.vim line 198
Called 12 times
Total time:   0.005817
 Self time:   0.005817

count  total (s)   self (s)
   12              0.000108   let bidx_mode = get(g:, 'airline#extensions#tabline#buffer_idx_mode', 1)
   12              0.000037   if bidx_mode > 0
   12              0.000028     if bidx_mode == 1
  120              0.000386       for i in range(1, 9)
  108              0.004050         exe printf('noremap <silent> <Plug>AirlineSelectTab%d :call <SID>select_tab(%d)<CR>', i, i-1)
  120              0.000193       endfor
                                else
                                  let start_idx = bidx_mode == 2 ? 11 : 1
                                  for i in range(start_idx, 99)
                                    exe printf('noremap <silent> <Plug>AirlineSelectTab%02d :call <SID>select_tab(%d)<CR>', i, i-start_idx)
                                  endfor
   12              0.000016     endif
   12              0.000325     noremap <silent> <Plug>AirlineSelectPrevTab :<C-u>call <SID>jump_to_tab(-v:count1)<CR>
   12              0.000285     noremap <silent> <Plug>AirlineSelectNextTab :<C-u>call <SID>jump_to_tab(v:count1)<CR>
                                " Enable this for debugging
                                " com! AirlineBufferList :echo map(copy(s:current_visible_buffers), {i,k -> k.": ".bufname(k)})
   12              0.000017   endif

FUNCTION  airline#extensions#tabline#buffers#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buffers.vim line 51
Called 12 times
Total time:   0.006591
 Self time:   0.000774

count  total (s)   self (s)
   12              0.000028   try
   12   0.006072   0.000255     call <sid>map_keys()
                              catch
                                " no-op
   12              0.000023   endtry
   12              0.000081   let cur = bufnr('%')
   12              0.000101   if cur == s:current_bufnr && &columns == s:column_width
   12              0.000139     if !g:airline_detect_modified || getbufvar(cur, '&modified') == s:current_modified
   12              0.000060       return s:current_tabline
                                endif
                              endif
                            
                              let b = airline#extensions#tabline#new_builder()
                              let tab_bufs = tabpagebuflist(tabpagenr())
                              let show_buf_label_first = 0
                            
                              if get(g:, 'airline#extensions#tabline#buf_label_first', 0)
                                let show_buf_label_first = 1
                              endif
                              if show_buf_label_first
                                call airline#extensions#tabline#add_label(b, 'buffers', 0)
                              endif
                            
                              let b.tab_bufs = tabpagebuflist(tabpagenr())
                            
                              let b.overflow_group = 'airline_tabhid'
                              let b.buffers = airline#extensions#tabline#buflist#list()
                              if get(g:, 'airline#extensions#tabline#current_first', 0)
                                if index(b.buffers, cur) > -1
                                  call remove(b.buffers, index(b.buffers, cur))
                                endif
                                let b.buffers = [cur] + b.buffers
                              endif
                            
                              function! b.get_group(i) dict
                                let bufnum = get(self.buffers, a:i, -1)
                                if bufnum == -1
                                  return ''
                                endif
                                let group = airline#extensions#tabline#group_of_bufnr(self.tab_bufs, bufnum)
                                if bufnum == bufnr('%')
                                  let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
                                endif
                                return group
                              endfunction
                            
                              if has("tablineat")
                                function! b.get_pretitle(i) dict
                                  let bufnum = get(self.buffers, a:i, -1)
                                  return '%'.bufnum.'@airline#extensions#tabline#buffers#clickbuf@'
                                endfunction
                            
                                function! b.get_posttitle(i) dict
                                  return '%X'
                                endfunction
                              endif
                            
                              function! b.get_title(i) dict
                                let bufnum = get(self.buffers, a:i, -1)
                                let group = self.get_group(a:i)
                                let pgroup = self.get_group(a:i - 1)
                                " always add a space when powerline_fonts are used
                                " or for the very first item
                                if get(g:, 'airline_powerline_fonts', 0) || a:i == 0
                                  let space = s:spc
                                else
                                  let space= (pgroup == group ? s:spc : '')
                                endif
                            
                                if get(g:, 'airline#extensions#tabline#buffer_idx_mode', 0)
                                  if len(s:number_map) > 0
                                    return space. s:get_number(a:i) . '%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)' . s:spc
                                  else
                                    return '['.(a:i+1).s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.']'
                                  endif
                                else
                                  return space.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.s:spc
                                endif
                              endfunction
                            
                              let current_buffer = max([index(b.buffers, cur), 0])
                              let last_buffer = len(b.buffers) - 1
                              call b.insert_titles(current_buffer, 0, last_buffer)
                            
                              call b.add_section('airline_tabfill', '')
                              call b.split()
                              call b.add_section('airline_tabfill', '')
                              if !show_buf_label_first
                                call airline#extensions#tabline#add_label(b, 'buffers', 1)
                              endif
                            
                              call airline#extensions#tabline#add_tab_label(b)
                            
                              let s:current_bufnr = cur
                              let s:column_width = &columns
                              let s:current_tabline = b.build()
                              let s:current_visible_buffers = copy(b.buffers)
                              " Do not remove from s:current_visible_buffers, this breaks s:select_tab()
                              "if b._right_title <= last_buffer
                              "  call remove(s:current_visible_buffers, b._right_title, last_buffer)
                              "endif
                              "if b._left_title > 0
                              "  call remove(s:current_visible_buffers, 0, b._left_title)
                              "endif
                              return s:current_tabline

FUNCTION  airline#highlighter#highlight()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim line 243
Called 18 times
Total time:   0.287862
 Self time:   0.046610

count  total (s)   self (s)
   18              0.000073   let bufnr = a:0 ? a:1 : ''
   18              0.000101   let p = g:airline#themes#{g:airline_theme}#palette
                            
                              " draw the base mode, followed by any overrides
   18              0.000291   let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
   18              0.000063   let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
   18              0.000050   let airline_grouplist = []
   18              0.000104   let buffers_in_tabpage = sort(tabpagebuflist())
   18              0.000056   if exists("*uniq")
   18              0.000067     let buffers_in_tabpage = uniq(buffers_in_tabpage)
   18              0.000016   endif
                              " mapped might be something like ['normal', 'normal_modified']
                              " if a group is in both modes available, only define the second
                              " that is how this was done previously overwrite the previous definition
   54              0.000121   for mode in reverse(mapped)
   36              0.000255     if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
   32              0.000121       let dict = g:airline#themes#{g:airline_theme}#palette[mode]
  592              0.000940       for kvp in items(dict)
  560              0.000875         let mode_colors = kvp[1]
  560              0.000730         let name = kvp[0]
  560              0.001263         if name is# 'airline_c' && !empty(bufnr) && suffix is# '_inactive'
                                      let name = 'airline_c'.bufnr
  560              0.000214         endif
                                    " do not re-create highlighting for buffers that are no longer visible
                                    " in the current tabpage
  560              0.002629         if name =~# 'airline_c\d\+'
                                      let bnr = matchstr(name, 'airline_c\zs\d\+') + 0
                                      if bnr > 0 && index(buffers_in_tabpage, bnr) == -1
                                        continue
                                      endif
  560              0.002171         elseif (name =~# '_to_') || (name[0:10] is# 'airline_tab' && !empty(suffix))
                                      " group will be redefined below at exec_separator
                                      " or is not needed for tabline with '_inactive' suffix
                                      " since active flag is 1 for builder)
  352              0.000238           continue
  208              0.000072         endif
  208   0.003070   0.001546         if s:group_not_done(airline_grouplist, name.suffix)
  144   0.035208   0.001238           call airline#highlighter#exec(name.suffix, mode_colors)
  208              0.000087         endif
                            
  208              0.000402         if !has_key(p, 'accents') 
                                      " work around a broken installation
                                      " shouldn't actually happen, p should always contain accents
                                      continue
  208              0.000089         endif
                            
  832              0.001166         for accent in keys(s:accents)
  624              0.001182           if !has_key(p.accents, accent)
  208              0.000135             continue
  416              0.000148           endif
  416              0.001195           let colors = copy(mode_colors)
  416              0.000835           if p.accents[accent][0] != ''
                                        let colors[0] = p.accents[accent][0]
  416              0.000151           endif
  416              0.000627           if p.accents[accent][2] != ''
  208              0.000408             let colors[2] = p.accents[accent][2]
  416              0.000154           endif
  416              0.000630           if len(colors) >= 5
  402              0.001122             let colors[4] = get(p.accents[accent], 4, '')
   14              0.000005           else
   14              0.000038             call add(colors, get(p.accents[accent], 4, ''))
  416              0.000152           endif
  416   0.006365   0.003531           if s:group_not_done(airline_grouplist, name.suffix.'_'.accent)
  288   0.066443   0.002558             call airline#highlighter#exec(name.suffix.'_'.accent, colors)
  416              0.000170           endif
  624              0.000309         endfor
  240              0.000100       endfor
                            
   32              0.000057       if empty(s:separators)
                                    " nothing to be done
                                    continue
   32              0.000011       endif
                                  " TODO: optimize this
  384              0.000559       for sep in items(s:separators)
                                    " we cannot check, that the group already exists, else the separators
                                    " might not be correctly defined. But perhaps we can skip above groups
                                    " that match the '_to_' name, because they would be redefined here...
  352   0.142460   0.003421         call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
  384              0.000187       endfor
   36              0.000016     endif
   54              0.000053   endfor

FUNCTION  coc#util#cursor()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/util.vim line 90
Called 18 times
Total time:   0.000545
 Self time:   0.000545

count  total (s)   self (s)
   18              0.000195   let pos = getcurpos()
   18              0.000193   let content = pos[2] == 1 ? '' : getline('.')[0: pos[2] - 2]
   18              0.000112   return [pos[1] - 1, strchars(content)]

FUNCTION  airline#extensions#coc#get_warning()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/coc.vim line 10
Called 105 times
Total time:   0.003696
 Self time:   0.000862

count  total (s)   self (s)
  105   0.003648   0.000815   return airline#extensions#coc#get('warning')

FUNCTION  airline#parts#filetype()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim line 102
Called 105 times
Total time:   0.002319
 Self time:   0.001306

count  total (s)   self (s)
  105   0.002202   0.001189   return (airline#util#winwidth() < 90 && strlen(&filetype) > 3) ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? '…' : '>') : &filetype

FUNCTION  airline#parts#iminsert()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim line 82
Called 105 times
Total time:   0.000734
 Self time:   0.000734

count  total (s)   self (s)
  105              0.000341   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
  105              0.000053   endif
  105              0.000085   return ''

FUNCTION  <SNR>194_getKind()
    Defined: ~/.vim/plugged/tagbar/autoload/tagbar/prototypes/typeinfo.vim line 17
Called 13 times
Total time:   0.000089
 Self time:   0.000089

count  total (s)   self (s)
   13              0.000039     let idx = self.kinddict[a:kind]
   13              0.000042     return self.kinds[idx]

FUNCTION  airline#update_tabline()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim line 273
Called 30 times
Total time:   0.000258
 Self time:   0.000258

count  total (s)   self (s)
   30              0.000131   if get(g:, 'airline_statusline_ontop', 0)
                                call airline#extensions#tabline#redraw()
   30              0.000022   endif

FUNCTION  gitgutter#hunk#summary()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim line 18
Called 105 times
Total time:   0.003597
 Self time:   0.001442

count  total (s)   self (s)
  105   0.003534   0.001378   return gitgutter#utility#getbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  coc#_hide()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc.vim line 94
Called 2 times
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    2              0.000009   if !pumvisible() | return | endif
                              call feedkeys("\<C-e>", 'in')

FUNCTION  airline#extensions#coc#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/coc.vim line 18
Called 210 times
Total time:   0.005234
 Self time:   0.005234

count  total (s)   self (s)
  210              0.000699   if !exists(':CocCommand')
                                return ''
  210              0.000107   endif
  210              0.000599   let _backup = get(g:, 'coc_stl_format', '')
  210              0.000510   let is_err = (a:type  is# 'error')
  210              0.000198   if is_err
  105              0.000407     let g:coc_stl_format = get(g:, 'airline#extensions#coc#stl_format_err', '%E{[%e(#%fe)]}')
  105              0.000057   else
  105              0.000463     let g:coc_stl_format = get(g:, 'airline#extensions#coc#stl_format_warn', '%W{[%w(#%fw)]}')
  210              0.000107   endif
  210              0.000536   let info = get(b:, 'coc_diagnostic_info', {})
  210              0.000525   if empty(info) | return '' | endif
                            
                            
                              let cnt = get(info, a:type, 0)
                              if !empty(_backup)
                                let g:coc_stl_format = _backup
                              endif
                            
                              if empty(cnt)
                                return ''
                              else
                                return (is_err ? s:error_symbol : s:warning_symbol).cnt
                              endif

FUNCTION  <SNR>199_get()
    Defined: ~/.vim/plugged/tagbar/autoload/tagbar/state.vim line 13
Called 32 times
Total time:   0.000808
 Self time:   0.000808

count  total (s)   self (s)
   32              0.000338     if !exists('t:tagbar_state')
                                    let t:tagbar_state = s:State.New()
   32              0.000042     endif
                            
   32              0.000098     return t:tagbar_state

FUNCTION  <SNR>39_notify()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/client.vim line 137
Called 74 times
Total time:   0.008800
 Self time:   0.008085

count  total (s)   self (s)
   74   0.001836   0.001121   let channel = coc#client#get_channel(self)
   74              0.000364   if empty(channel) | return '' | endif
   74              0.000105   try
   74              0.000128     if s:is_vim
                                  call ch_sendraw(channel, json_encode([0, [a:method, a:args]])."\n")
   74              0.000146     else
   74              0.002540       call call('rpcnotify', [channel, a:method] + a:args)
   74              0.000125     endif
                              catch /.*/
                                if v:exception =~# 'E475'
                                  if get(g:, 'coc_vim_leaving', 0) | return | endif
                                  echohl Error | echom '['.self.name.'] server connection lost' | echohl None
                                  let name = self.name
                                  call s:on_exit(name, 0)
                                  execute 'silent do User ConnectionLost'.toupper(name[0]).name[1:]
                                elseif v:exception =~# 'E12'
                                  " neovim's bug, ignore it
                                else
                                  echohl Error | echo 'Error on notify ('.a:method.'): '.v:exception | echohl None
                                endif
   74              0.000113   endtry

FUNCTION  gitgutter#utility#has_repo_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim line 108
Called 9 times
Total time:   0.000992
 Self time:   0.000290

count  total (s)   self (s)
    9   0.000982   0.000280   return index(['', -1, -2], gitgutter#utility#repo_path(a:bufnr, 0)) == -1

FUNCTION  airline#extensions#tabline#buflist#list()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buflist.vim line 35
Called 12 times
Total time:   0.000155
 Self time:   0.000155

count  total (s)   self (s)
   12              0.000095   if exists('s:current_buffer_list')
   12              0.000040     return s:current_buffer_list
                              endif
                            
                              let exclude_buffers = get(g:, 'airline#extensions#tabline#exclude_buffers', [])
                              let exclude_paths = get(g:, 'airline#extensions#tabline#excludes', [])
                              let exclude_preview = get(g:, 'airline#extensions#tabline#exclude_preview', 1)
                            
                              let list = (exists('g:did_bufmru') && g:did_bufmru) ? BufMRUList() : range(1, bufnr("$"))
                            
                              let buffers = []
                              " If this is too slow, we can switch to a different algorithm.
                              " Basically branch 535 already does it, but since it relies on
                              " BufAdd autocommand, I'd like to avoid this if possible.
                              for nr in list
                                if buflisted(nr)
                                  " Do not add to the bufferlist, if either
                                  " 1) bufnr is exclude_buffers list
                                  " 2) buffername matches one of exclude_paths patterns
                                  " 3) buffer is a quickfix buffer
                                  " 4) when excluding preview windows:
                                  "     'bufhidden' == wipe
                                  "     'buftype' == nofile
                                  " 5) ignore buffers matching airline#extensions#tabline#ignore_bufadd_pat
                            
                                  " check buffer numbers first
                                  if index(exclude_buffers, nr) >= 0
                                    continue
                                  " check paths second
                                  elseif !empty(exclude_paths) && s:ExcludePaths(nr, exclude_paths)
                                    continue
                                  " ignore buffers matching airline#extensions#tabline#ignore_bufadd_pat
                                  elseif airline#util#ignore_buf(bufname(nr))
                                    continue
                                  " check other types last
                                  elseif s:ExcludeOther(nr, exclude_preview)
                                    continue
                                  endif
                            
                                  call add(buffers, nr)
                                endif
                              endfor
                            
                              let s:current_buffer_list = buffers
                              return buffers

FUNCTION  provider#python3#Call()
    Defined: /usr/share/nvim/runtime/autoload/provider/python3.vim line 26
Called 38 times
Total time:   0.161162
 Self time:   0.161162

count  total (s)   self (s)
   38              0.000155   if s:err != ''
                                return
   38              0.000035   endif
   38              0.000134   if !exists('s:host')
                                let s:rpcrequest = function('rpcrequest')
                            
                                " Ensure that we can load the Python3 host before bootstrapping
                                try
                                  let s:host = remote#host#Require('legacy-python3-provider')
                                catch
                                  let s:err = v:exception
                                  echohl WarningMsg
                                  echomsg v:exception
                                  echohl None
                                  return
                                endtry
   38              0.000022   endif
   38              0.160122   return call(s:rpcrequest, insert(insert(a:args, 'python_'.a:method), s:host))

FUNCTION  313()
    Defined: ~/.vim/plugged/vimtex/autoload/vimtex/compiler/latexmk.vim line 649
Called 105 times
Total time:   0.003102
 Self time:   0.003102

count  total (s)   self (s)
  105              0.000120   try
  105              0.001132     let pid = jobpid(self.job)
                                return 1
  105              0.001191   catch
  105              0.000239     return 0
  105              0.000135   endtry

FUNCTION  airline#extensions#tabline#formatters#webdevicons#format()
    Defined: ~/.vim/plugged/vim-devicons/autoload/airline/extensions/tabline/formatters/webdevicons.vim line 6
Called 12 times
Total time:   0.007334
 Self time:   0.000792

count  total (s)   self (s)
                              " Call original formatter.
   12   0.002195   0.000403   let originalFormatter = airline#extensions#tabline#formatters#{g:_webdevicons_airline_orig_formatter}#format(a:bufnr, a:buffers)
   12   0.005093   0.000344   return originalFormatter . g:WebDevIconsTabAirLineBeforeGlyphPadding . WebDevIconsGetFileTypeSymbol(bufname(a:bufnr)) . g:WebDevIconsTabAirLineAfterGlyphPadding

FUNCTION  coc#_do_complete()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc.vim line 69
Called 4 times
Total time:   0.000234
 Self time:   0.000234

count  total (s)   self (s)
    4              0.000119   let g:coc#_context = { 'start': a:start, 'candidates': a:items, 'preselect': a:preselect}
    4              0.000069   if mode() =~# 'i' && &paste != 1
    4              0.000034     call feedkeys("\<Plug>CocRefresh", 'i')
    4              0.000004   endif

FUNCTION  gitgutter#utility#cd_cmd()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim line 170
Called 9 times
Total time:   0.005921
 Self time:   0.000599

count  total (s)   self (s)
    9   0.004288   0.000383   let cd = s:unc_path(a:bufnr) ? 'pushd' : (gitgutter#utility#windows() ? 'cd /d' : 'cd')
    9   0.001619   0.000202   return cd.' '.s:dir(a:bufnr).' && '.a:cmd

FUNCTION  <SNR>116_get_timeout()
    Defined: ~/.vim/plugged/vimtex/autoload/vimtex/delim.vim line 880
Called 30 times
Total time:   0.000182
 Self time:   0.000182

count  total (s)   self (s)
   30              0.000169   return (empty(v:insertmode) ? mode() : v:insertmode) ==# 'i' ? g:vimtex_delim_insert_timeout : g:vimtex_delim_timeout

FUNCTION  tagbar#debug#log()
    Defined: ~/.vim/plugged/tagbar/autoload/tagbar/debug.vim line 30
Called 30 times
Total time:   0.000636
 Self time:   0.000636

count  total (s)   self (s)
   30              0.000140     if s:debug_enabled
                                    execute 'redir >> ' . s:debug_file
                                    silent echon s:gettime() . ': ' . a:msg . "\n"
                                    redir END
   30              0.000045     endif

FUNCTION  airline#util#winwidth()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim line 19
Called 1047 times
Total time:   0.009744
 Self time:   0.009744

count  total (s)   self (s)
 1047              0.003051   let nr = get(a:000, 0, 0)
 1047              0.002395   if get(g:, 'airline_statusline_ontop', 0)
                                return &columns
 1047              0.000624   else
 1047              0.001984     return winwidth(nr)
                              endif

FUNCTION  vimtex#util#in_comment()
    Defined: ~/.vim/plugged/vimtex/autoload/vimtex/util.vim line 50
Called 23 times
Total time:   0.005256
 Self time:   0.000457

count  total (s)   self (s)
   23   0.005235   0.000436   return call('vimtex#util#in_syntax', ['texComment'] + a:000)

FUNCTION  airline#util#doautocmd()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim line 176
Called 18 times
Total time:   0.001087
 Self time:   0.000293

count  total (s)   self (s)
   18   0.001081   0.000287   exe printf("silent doautocmd %s User %s", s:nomodeline, a:event)

FUNCTION  coc#util#get_complete_option()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/util.vim line 406
Called 2 times
Total time:   0.000204
 Self time:   0.000204

count  total (s)   self (s)
    2              0.000008   let disabled = get(b:, 'coc_suggest_disable', 0)
    2              0.000005   if disabled | return | endif
    2              0.000005   let blacklist = get(b:, 'coc_suggest_blacklist', [])
    2              0.000005   let pos = getcurpos()
    2              0.000005   let l:start = pos[2] - 1
    2              0.000005   let line = getline(pos[1])
    4              0.000020   for char in reverse(split(line[0: l:start - 1], '\zs'))
    2              0.000008     if l:start > 0 && char =~# '\k'
    2              0.000005       let l:start = l:start - strlen(char)
                                else
                                  break
    2              0.000001     endif
    4              0.000003   endfor
    2              0.000007   let input = pos[2] == 1 ? '' : line[l:start : pos[2] - 2]
    2              0.000006   if !empty(blacklist) && index(blacklist, input) >= 0
                                return
    2              0.000001   endif
    2              0.000009   let synname = synIDattr(synID(pos[1], l:start, 1),"name")
    2              0.000091   return { 'word': matchstr(line[l:start : ], '^\k\+'), 'input': input, 'line': line, 'filetype': &filetype, 'filepath': expand('%:p'), 'bufnr': bufnr('%'), 'linenr': pos[1], 'colnr' : pos[2], 'col': l:start, 'synname': synname, 'blacklist': blacklist,}

FUNCTION  airline#extensions#wordcount#formatters#default#to_string()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/wordcount/formatters/default.vim line 26
Called 4 times
Total time:   0.000141
 Self time:   0.000108

count  total (s)   self (s)
    4   0.000057   0.000024   if airline#util#winwidth() > 85
    4              0.000005     if a:wordcount > 999
                                  " Format number according to locale, e.g. German: 1.245 or English: 1,245
                                  let wordcount = substitute(a:wordcount, '\d\@<=\(\(\d\{3\}\)\+\)$', s:decimal_group.'&', 'g')
    4              0.000002     else
    4              0.000006       let wordcount = a:wordcount
    4              0.000002     endif
    4              0.000014     let str = printf(s:fmt, wordcount)
                              else
                                let str = printf(s:fmt_short, a:wordcount)
    4              0.000002   endif
    4              0.000027   return str . g:airline_symbols.space . g:airline_right_alt_sep . g:airline_symbols.space

FUNCTION  tagbar#is_paused()
    Defined: ~/.vim/plugged/tagbar/autoload/tagbar.vim line 3508
Called 27 times
Total time:   0.000113
 Self time:   0.000113

count  total (s)   self (s)
   27              0.000077     return s:paused

FUNCTION  <SNR>116_get_matching_delim()
    Defined: ~/.vim/plugged/vimtex/autoload/vimtex/delim.vim line 823
Called 15 times
Total time:   0.003290
 Self time:   0.003194

count  total (s)   self (s)
   15              0.000016   try
   15   0.002947   0.002852     let [lnum, cnum] = searchpairpos(self.re.open, '', self.re.close, self.gms_flags, 'synIDattr(synID(line("."), col("."), 0), "name") =~? "comment"', 0, s:get_timeout())
                              catch /E118/
                                let [lnum, cnum] = searchpairpos(self.re.open, '', self.re.close, self.gms_flags, 'synIDattr(synID(line("."), col("."), 0), "name") =~? "comment"', self.gms_stopline)
   15              0.000016   endtry
                            
   15              0.000149   let match = matchstr(getline(lnum), '^' . self.re.corr, cnum-1)
   15              0.000038   return [match, lnum, cnum]

FUNCTION  <SNR>191_IsValidFile()
    Defined: ~/.vim/plugged/tagbar/autoload/tagbar.vim line 3114
Called 5 times
Total time:   0.001232
 Self time:   0.001143

count  total (s)   self (s)
    5   0.000244   0.000155     call tagbar#debug#log('Checking if file is valid [' . a:fname . ']')
                            
    5              0.000035     if a:fname ==# '' || a:ftype ==# ''
                                    call tagbar#debug#log('Empty filename or type')
                                    return 0
    5              0.000007     endif
                            
    5              0.000147     if !filereadable(a:fname) && getbufvar(a:fname, 'netrw_tmpfile') ==# ''
                                    call tagbar#debug#log('File not readable')
                                    return 0
    5              0.000007     endif
                            
    5              0.000148     if getbufvar(a:fname, 'tagbar_ignore') == 1
                                    call tagbar#debug#log('File is marked as ignored')
                                    return 0
    5              0.000007     endif
                            
    5              0.000130     let winnr = bufwinnr(a:fname)
    5              0.000056     if winnr != -1 && getwinvar(winnr, '&diff')
                                    call tagbar#debug#log('Window is in diff mode')
                                    return 0
    5              0.000007     endif
                            
    5              0.000019     if &previewwindow
                                    call tagbar#debug#log('In preview window')
                                    return 0
    5              0.000006     endif
                            
    5              0.000047     if !has_key(s:known_types, a:ftype)
                                    if exists('g:tagbar_type_' . a:ftype)
                                        " Filetype definition must have been specified in an 'ftplugin'
                                        " file, so load it now
                                        call s:LoadUserTypeDefs(a:ftype)
                                    else
                                        call tagbar#debug#log('Unsupported filetype: ' . a:ftype)
                                        return 0
                                    endif
    5              0.000007     endif
                            
    5              0.000013     return 1

FUNCTION  <SNR>181_on_exit_nvim()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim line 69
Called 9 times
Total time:   0.000052
 Self time:   0.000052

count  total (s)   self (s)
    9              0.000020   if !a:exit_code
                                call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))
    9              0.000003   endif

FUNCTION  vimtex#delim#get_next()
    Defined: ~/.vim/plugged/vimtex/autoload/vimtex/delim.vim line 287
Called 45 times
Total time:   0.027921
 Self time:   0.000972

count  total (s)   self (s)
   45   0.027901   0.000952   return s:get_delim(extend({ 'direction' : 'next', 'type' : a:type, 'side' : a:side,}, get(a:, '1', {})))

FUNCTION  <SNR>181_build_command()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim line 40
Called 9 times
Total time:   0.000123
 Self time:   0.000123

count  total (s)   self (s)
    9              0.000045   if has('unix')
    9              0.000060     return ['sh', '-c', a:cmd]
                              endif
                            
                              if has('win32')
                                return has('nvim') ? ['cmd.exe', '/c', a:cmd] : 'cmd.exe /c '.a:cmd
                              endif
                            
                              throw 'unknown os'

FUNCTION  <SNR>162_hl_group_exists()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim line 95
Called 540 times
Total time:   0.004569
 Self time:   0.004569

count  total (s)   self (s)
  540              0.001066   if !hlexists(a:group)
                                return 0
  540              0.001905   elseif empty(synIDattr(hlID(a:group), 'fg'))
                                return 0
  540              0.000209   endif
  540              0.000352   return 1

FUNCTION  <SNR>113_text_between()
    Defined: ~/.vim/plugged/vimtex/autoload/vimtex/cmd.vim line 420
Called 60 times
Total time:   0.001461
 Self time:   0.001461

count  total (s)   self (s)
   60              0.000259   let [l1, c1] = [a:p1.lnum, a:p1.cnum - (a:0 > 0)]
   60              0.000184   let [l2, c2] = [a:p2.lnum, a:p2.cnum - (a:0 <= 0)]
                            
   60              0.000182   let lines = getline(l1, l2)
   60              0.000106   if !empty(lines)
   60              0.000201     let lines[0] = strpart(lines[0], c1)
   60              0.000243     let lines[-1] = strpart(lines[-1], 0, l1 == l2 ? c2 - c1 : c2)
   60              0.000034   endif
   60              0.000170   return join(lines, "\n")

FUNCTION  vimtex#delim#get_matching()
    Defined: ~/.vim/plugged/vimtex/autoload/vimtex/delim.vim line 314
Called 30 times
Total time:   0.016225
 Self time:   0.002630

count  total (s)   self (s)
   30              0.000152   if empty(a:delim) || !has_key(a:delim, 'lnum') | return {} | endif
                            
                              "
                              " Get the matching position
                              "
   30   0.000366   0.000212   let l:save_pos = vimtex#pos#get_cursor()
   30   0.000936   0.000206   call vimtex#pos#set_cursor(a:delim)
   30   0.004321   0.000322   let [l:match, l:lnum, l:cnum] = a:delim.get_matching()
   30   0.001158   0.000247   call vimtex#pos#set_cursor(l:save_pos)
                            
                              "
                              " Create the match result
                              "
   30              0.000442   let l:matching = deepcopy(a:delim)
   30              0.000064   let l:matching.lnum = l:lnum
   30              0.000042   let l:matching.cnum = l:cnum
   30              0.000050   let l:matching.match = l:match
   30              0.000052   let l:matching.corr  = a:delim.match
   30              0.000065   let l:matching.side = a:delim.is_open ? 'close' : 'open'
   30              0.000054   let l:matching.is_open = !a:delim.is_open
   30              0.000056   let l:matching.re.corr = a:delim.re.this
   30              0.000049   let l:matching.re.this = a:delim.re.corr
                            
   30              0.000053   if l:matching.type ==# 'delim'
   15              0.000028     let l:matching.corr_delim = a:delim.delim
   15              0.000044     let l:matching.corr_mod = a:delim.mod
   15              0.000026     let l:matching.delim = a:delim.corr_delim
   15              0.000024     let l:matching.mod = a:delim.corr_mod
   15              0.000048   elseif l:matching.type ==# 'env' && has_key(l:matching, 'name')
   15              0.000016     if l:matching.is_open
    1              0.002485       let l:matching.env_cmd = vimtex#cmd#get_at(l:lnum, l:cnum)
   14              0.000006     else
   14              0.000117       unlet l:matching.env_cmd
   15              0.000008     endif
   30              0.000014   endif
                            
   30              0.000038   return l:matching

FUNCTION  vimtex#pos#set_cursor()
    Defined: ~/.vim/plugged/vimtex/autoload/vimtex/pos.vim line 7
Called 263 times
Total time:   0.008654
 Self time:   0.002540

count  total (s)   self (s)
  263   0.008545   0.002430   call cursor(s:parse_args(a:000))

FUNCTION  <SNR>116_parser_env()
    Defined: ~/.vim/plugged/vimtex/autoload/vimtex/delim.vim line 537
Called 15 times
Total time:   0.041823
 Self time:   0.001300

count  total (s)   self (s)
   15              0.000036   let result = {}
                            
   15              0.000037   let result.type = 'env'
   15              0.000146   let result.name = matchstr(a:match, '{\zs\k*\ze\*\?}')
   15              0.000098   let result.starred = match(a:match, '\*}$') > 0
   15              0.000079   let result.side = a:match =~# '\\begin' ? 'open' : 'close'
   15              0.000044   let result.is_open = result.side ==# 'open'
   15              0.000088   let result.get_matching = function('s:get_matching_env')
                            
   15              0.000042   let result.gms_flags = result.is_open ? 'nW' : 'bnW'
   15              0.000112   let result.gms_stopline = result.is_open ? line('.') + g:vimtex_delim_stopline : max([1, line('.') - g:vimtex_delim_stopline])
                            
   15              0.000022   if result.is_open
   14   0.040698   0.000175     let result.env_cmd = vimtex#cmd#get_at(a:lnum, a:cnum)
   15              0.000008   endif
                            
   15              0.000134   let result.corr = result.is_open ? substitute(a:match, 'begin', 'end', '') : substitute(a:match, 'end', 'begin', '')
                            
   15              0.000080   let result.re = { 'open' : '\m\\begin\s*{' . result.name . '\*\?}', 'close' : '\m\\end\s*{' . result.name . '\*\?}',}
                            
   15              0.000053   let result.re.this = result.is_open ? result.re.open  : result.re.close
   15              0.000041   let result.re.corr = result.is_open ? result.re.close : result.re.open
                            
   15              0.000020   return result

FUNCTION  <SNR>66_abs_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim line 193
Called 45 times
Total time:   0.004241
 Self time:   0.004241

count  total (s)   self (s)
   45              0.003795   let p = resolve(expand('#'.a:bufnr.':p'))
   45              0.000385   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  tagbar#state#get_current_file()
    Defined: ~/.vim/plugged/tagbar/autoload/tagbar/state.vim line 1
Called 27 times
Total time:   0.002111
 Self time:   0.000833

count  total (s)   self (s)
   27   0.002070   0.000791     return s:get().getCurrent(a:force_current)

FUNCTION  <SNR>116_get_delim()
    Defined: ~/.vim/plugged/vimtex/autoload/vimtex/delim.vim line 425
Called 68 times
Total time:   0.078284
 Self time:   0.016901

count  total (s)   self (s)
                              "
                              " Arguments:
                              "   opts = {
                              "     'direction'   :  next
                              "                      prev
                              "                      current
                              "     'type'        :  env_tex
                              "                      env_math
                              "                      env_all
                              "                      delim_tex
                              "                      delim_math
                              "                      delim_modq_math (possibly modified math delimiter)
                              "                      delim_mod_math  (modified math delimiter)
                              "                      delim_all
                              "                      all
                              "     'side'        :  open
                              "                      close
                              "                      both
                              "     'syn_exclude' :  Don't match in given syntax
                              "  }
                              "
                              " Returns:
                              "   delim = {
                              "     type    : env | delim
                              "     side    : open | close
                              "     name    : name of environment [only for type env]
                              "     lnum    : number
                              "     cnum    : number
                              "     match   : unparsed matched delimiter
                              "     corr    : corresponding delimiter
                              "     re : {
                              "       open  : regexp for the opening part
                              "       close : regexp for the closing part
                              "     }
                              "     remove  : method to remove the delimiter
                              "   }
                              "
   68   0.001148   0.000622   let l:save_pos = vimtex#pos#get_cursor()
   68              0.000399   let l:re = g:vimtex#delim#re[a:opts.type][a:opts.side]
   68              0.000107   while 1
   68              0.003747     let [l:lnum, l:cnum] = a:opts.direction ==# 'next' ? searchpos(l:re, 'cnW', line('.') + g:vimtex_delim_stopline) : a:opts.direction ==# 'prev'   ? searchpos(l:re, 'bcnW', max([line('.') - g:vimtex_delim_stopline, 1]))   : searchpos(l:re, 'bcnW', line('.'))
   68              0.000264     if l:lnum == 0 | break | endif
                            
   60              0.000320     if has_key(a:opts, 'syn_exclude') && vimtex#util#in_syntax(a:opts.syn_exclude, l:lnum, l:cnum)
                                  call vimtex#pos#set_cursor(vimtex#pos#prev(l:lnum, l:cnum))
                                  continue
   60              0.000034     endif
                            
   60              0.000050     break
   68              0.000109   endwhile
   68   0.003311   0.000692   call vimtex#pos#set_cursor(l:save_pos)
                            
   68              0.002341   let l:match = matchstr(getline(l:lnum), '^' . l:re, l:cnum-1)
                            
   68              0.000458   if a:opts.direction ==# 'current' && l:cnum + strlen(l:match) + (mode() ==# 'i' ? 1 : 0) <= col('.')
    8              0.000014     let l:match = ''
    8              0.000011     let l:lnum = 0
    8              0.000008     let l:cnum = 0
   68              0.000049   endif
                            
   68              0.000727   let l:result = { 'type' : '', 'lnum' : l:lnum, 'cnum' : l:cnum, 'match' : l:match, 'remove' : function('s:delim_remove'),}
                            
  288              0.000483   for l:type in s:types
  280              0.003318     if l:match =~# '^' . l:type.re
   60   0.021433   0.007647       let l:result = extend( l:type.parser(l:match, l:lnum, l:cnum,               a:opts.side, a:opts.type, a:opts.direction), l:result, 'keep')
   60              0.000052       break
  220              0.000100     endif
  288              0.000246   endfor
                            
   68              0.000212   return empty(l:result.type) ? {} : l:result

FUNCTION  airline#parts#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim line 49
Called 105 times
Total time:   0.000514
 Self time:   0.000514

count  total (s)   self (s)
  105              0.000468   return get(s:parts, a:key, {})

FUNCTION  airline#util#wrap()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim line 42
Called 840 times
Total time:   0.005907
 Self time:   0.005029

count  total (s)   self (s)
  840   0.003613   0.002735   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
  105              0.000088     return ''
  735              0.000370   endif
  735              0.000838   return a:text

FUNCTION  airline#extensions#tabline#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline.vim line 149
Called 12 times
Total time:   0.008162
 Self time:   0.001571

count  total (s)   self (s)
   12              0.000204   let show_buffers = get(g:, 'airline#extensions#tabline#show_buffers', 1)
   12              0.000088   let show_tabs = get(g:, 'airline#extensions#tabline#show_tabs', 1)
                            
   12              0.000112   let curtabcnt = tabpagenr('$')
   12              0.000066   if curtabcnt != s:current_tabcnt
                                let s:current_tabcnt = curtabcnt
                                call airline#extensions#tabline#tabs#invalidate()
                                call airline#extensions#tabline#buffers#invalidate()
                                call airline#extensions#tabline#ctrlspace#invalidate()
                                call airline#extensions#tabline#tabws#invalidate()
   12              0.000026   endif
                            
   12              0.000096   if !exists('#airline#BufAdd#*')
                                autocmd airline BufAdd * call <sid>update_tabline(0)
   12              0.000014   endif
   12              0.000071   if !exists('#airline#SessionLoadPost')
                                autocmd airline SessionLoadPost * call <sid>update_tabline(1)
   12              0.000011   endif
   12              0.000028   if s:ctrlspace
                                return airline#extensions#tabline#ctrlspace#get()
   12              0.000031   elseif s:tabws
                                return airline#extensions#tabline#tabws#get()
   12              0.000064   elseif show_buffers && curtabcnt == 1 || !show_tabs
   12   0.006894   0.000303     return airline#extensions#tabline#buffers#get()
                              else
                                return airline#extensions#tabline#tabs#get()
                              endif

FUNCTION  188()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/creator.vim line 35
Called 10 times
Total time:   0.000057
 Self time:   0.000057

count  total (s)   self (s)
   10              0.000043     return 'NERD_tree_'

FUNCTION  <SNR>113_get_cmd_name()
    Defined: ~/.vim/plugged/vimtex/autoload/vimtex/cmd.vim line 367
Called 15 times
Total time:   0.000441
 Self time:   0.000441

count  total (s)   self (s)
   15              0.000215   let [l:lnum, l:cnum] = searchpos('\v\\\a+\*?', a:next ? 'nW' : 'cbnW')
   15              0.000164   let l:match = matchstr(getline(l:lnum), '^\v\\\a*\*?', l:cnum-1)
   15              0.000048   return [l:lnum, l:cnum, l:match]

FUNCTION  <SNR>113_get_cmd_part()
    Defined: ~/.vim/plugged/vimtex/autoload/vimtex/cmd.vim line 374
Called 45 times
Total time:   0.040669
 Self time:   0.002917

count  total (s)   self (s)
   45   0.000607   0.000350   let l:save_pos = vimtex#pos#get_cursor()
   45   0.001675   0.000368   call vimtex#pos#set_cursor(a:start_pos)
   45   0.028362   0.000441   let l:open = vimtex#delim#get_next('delim_tex', 'open')
   45   0.001900   0.000426   call vimtex#pos#set_cursor(l:save_pos)
                            
                              "
                              " Ensure that the delimiter
                              " 1) exists,
                              " 2) is of the right type,
                              " 3) and is the next non-whitespace character.
                              "
   45   0.001493   0.000708   if empty(l:open) || l:open.match !=# a:part || strlen(substitute(        s:text_between(a:start_pos, l:open), '\_s', '', 'g')) != 0
   30              0.000031     return {}
   15              0.000009   endif
                            
   15   0.005763   0.000153   let l:close = vimtex#delim#get_matching(l:open)
   15              0.000029   if empty(l:close)
                                return {}
   15              0.000008   endif
                            
   15   0.000594   0.000196   return { 'open' : l:open, 'close' : l:close, 'text' : s:text_between(l:open, l:close),}

FUNCTION  <SNR>166_conflict_marker()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim line 50
Called 2 times
Total time:   0.000410
 Self time:   0.000410

count  total (s)   self (s)
                              " Checks for git conflict markers
    2              0.000005   let annotation = '\%([0-9A-Za-z_.:]\+\)\?'
    2              0.000009   if &ft is# 'rst'
                                " rst filetypes use '=======' as header
                                let pattern = '^\%(\%(<\{7} '.annotation. '\)\|\%(>\{7\} '.annotation.'\)\)$'
    2              0.000001   else
    2              0.000010     let pattern = '^\%(\%(<\{7} '.annotation. '\)\|\%(=\{7\}\)\|\%(>\{7\} '.annotation.'\)\)$'
    2              0.000001   endif
    2              0.000375   return search(pattern, 'nw')

FUNCTION  airline#extensions#hunks#get_raw_hunks()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim line 46
Called 105 times
Total time:   0.010728
 Self time:   0.003379

count  total (s)   self (s)
  105              0.000522   if !exists('b:source_func') || get(b:, 'source_func', '') is# 's:get_hunks_empty'
                                if get(g:, 'loaded_signify') && sy#buffer_is_active()
                                  let b:source_func = 's:get_hunks_signify'
                                elseif exists('*GitGutterGetHunkSummary')
                                  let b:source_func = 's:get_hunks_gitgutter'
                                elseif exists('*changes#GetStats')
                                  let b:source_func = 's:get_hunks_changes'
                                elseif exists('*quickfixsigns#vcsdiff#GetHunkSummary')
                                  let b:source_func = 'quickfixsigns#vcsdiff#GetHunkSummary'
                                else
                                  let b:source_func = 's:get_hunks_empty'
                                endif
  105              0.000052   endif
  105   0.008539   0.001190   return {b:source_func}()

FUNCTION  <SNR>168_format_wordcount()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/wordcount.vim line 40
Called 4 times
Total time:   0.000192
 Self time:   0.000051

count  total (s)   self (s)
    4   0.000191   0.000049   return airline#extensions#wordcount#formatters#{s:formatter}#to_string(a:wordcount)

FUNCTION  <SNR>36_Autocmd()
    Defined: ~/.vim/plugged/coc.nvim/plugin/coc.vim line 143
Called 69 times
Total time:   0.012833
 Self time:   0.001846

count  total (s)   self (s)
   69              0.000712   if !get(g:,'coc_workspace_initialized', 0) | return | endif
   69   0.012019   0.001031   call coc#rpc#notify('CocAutocmd', a:000)

FUNCTION  <SNR>140_indent_delims()
    Defined: ~/.vim/plugged/vimtex/indent/tex.vim line 214
Called 1 time
Total time:   0.000661
 Self time:   0.000112

count  total (s)   self (s)
    1              0.000004   if s:re_opt.close_indented
                                return s:sw*(s:count(a:prev_line, s:re_open) - s:count(a:prev_line, s:re_close))
    1              0.000002   else
    1   0.000640   0.000091     return s:sw*(  max([  s:count(a:prev_line, s:re_open)             - s:count(a:prev_line, s:re_close), 0])      - max([  s:count(a:line, s:re_close)             - s:count(a:line, s:re_open), 0]))
                              endif

FUNCTION  <SNR>66_unc_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim line 175
Called 9 times
Total time:   0.000992
 Self time:   0.000250

count  total (s)   self (s)
    9   0.000985   0.000243   return s:abs_path(a:bufnr, 0) =~ '^\\\\'

FUNCTION  <SNR>162_CheckDefined()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim line 132
Called 802 times
Total time:   0.021401
 Self time:   0.021401

count  total (s)   self (s)
                              " Checks, whether the definition of the colors is valid and is not empty or NONE
                              " e.g. if the colors would expand to this:
                              " hi airline_c ctermfg=NONE ctermbg=NONE
                              " that means to clear that highlighting group, therefore, fallback to Normal
                              " highlighting group for the cterm values
                            
                              " This only works, if the Normal highlighting group is actually defined, so
                              " return early, if it has been cleared
  802              0.002247   if !exists("g:airline#highlighter#normal_fg_hi")
                                let g:airline#highlighter#normal_fg_hi = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
  802              0.000319   endif
  802              0.002295   if empty(g:airline#highlighter#normal_fg_hi) || g:airline#highlighter#normal_fg_hi < 0
                                return a:colors
  802              0.000294   endif
                            
 2310              0.002744   for val in a:colors
 2310              0.003914     if !empty(val) && val !=# 'NONE'
  802              0.000765       return a:colors
 1508              0.000610     endif
 1508              0.000752   endfor
                              " this adds the bold attribute to the term argument of the :hi command,
                              " but at least this makes sure, the group will be defined
                              let fg = g:airline#highlighter#normal_fg_hi
                              let bg = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
                              if bg < 0
                                " in case there is no background color defined for Normal
                                let bg = a:colors[3]
                              endif
                              return a:colors[0:1] + [fg, bg] + [a:colors[4]]

FUNCTION  <SNR>22_on_window_changed()
    Defined: ~/.vim/plugged/vim-airline/plugin/airline.vim line 59
Called 4 times
Total time:   0.000189
 Self time:   0.000189

count  total (s)   self (s)
                              " don't trigger for Vim popup windows
    4              0.000010   if &buftype is# 'popup'
                                return
    4              0.000002   endif
                            
    4              0.000011   if pumvisible() && (!&previewwindow || g:airline_exclude_preview)
                                " do not trigger for previewwindows
                                return
    4              0.000002   endif
    4              0.000016   let s:active_winnr = winnr()
                              " Handle each window only once, since we might come here several times for
                              " different autocommands.
    4              0.000050   let l:key = [bufnr('%'), s:active_winnr, winnr('$'), tabpagenr(), &ft]
    4              0.000065   if get(g:, 'airline_last_window_changed', []) == l:key && &stl is# '%!airline#statusline('.s:active_winnr.')' && &ft !~? 'gitcommit'
                                " fugitive is special, it changes names and filetypes several times,
                                " make sure the caching does not get into its way
    4              0.000004     return
                              endif
                              let g:airline_last_window_changed = l:key
                              call s:init()
                              call airline#update_statusline()

FUNCTION  <SNR>140_get_prev_lnum()
    Defined: ~/.vim/plugged/vimtex/indent/tex.vim line 69
Called 1 time
Total time:   0.000331
 Self time:   0.000114

count  total (s)   self (s)
    1              0.000006   let l:lnum = a:lnum
    1              0.000008   let l:line = getline(l:lnum)
                            
    1   0.000243   0.000051   while l:lnum != 0 && (l:line =~# '^\s*%' || s:is_verbatim(l:line, l:lnum))
                                let l:lnum = prevnonblank(l:lnum - 1)
                                let l:line = getline(l:lnum)
    1              0.000004   endwhile
                            
    1   0.000054   0.000029   return [ l:lnum, l:lnum > 0 ? s:clean_line(l:line) : '',]

FUNCTION  <SNR>166_check_mixed_indent_file()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim line 32
Called 2 times
Total time:   0.000129
 Self time:   0.000129

count  total (s)   self (s)
    2              0.000015   let c_like_langs = get(g:, 'airline#extensions#c_like_langs', [ 'arduino', 'c', 'cpp', 'cuda', 'go', 'javascript', 'ld', 'php' ])
    2              0.000017   if index(c_like_langs, &ft) > -1
                                " for C-like languages: allow /** */ comment style with one space before the '*'
                                let head_spc = '\v(^ +\*@!)'
    2              0.000002   else
    2              0.000003     let head_spc = '\v(^ +)'
    2              0.000001   endif
    2              0.000052   let indent_tabs = search('\v(^\t+)', 'nw')
    2              0.000017   let indent_spc  = search(head_spc, 'nw')
    2              0.000005   if indent_tabs > 0 && indent_spc > 0
                                return printf("%d:%d", indent_tabs, indent_spc)
    2              0.000001   else
    2              0.000002     return ''
                              endif

FUNCTION  gitgutter#debug#log()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/debug.vim line 80
Called 9 times
Total time:   0.000812
 Self time:   0.000812

count  total (s)   self (s)
    9              0.000035   if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif
                            
                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END
                            
                                let s:new_log_session = 0
    9              0.000014   endif

FUNCTION  coc#rpc#ready()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/rpc.vim line 31
Called 74 times
Total time:   0.001013
 Self time:   0.001013

count  total (s)   self (s)
   74              0.000565   if empty(s:client) || s:client['running'] == 0
                                return 0
   74              0.000071   endif
   74              0.000109   return 1

FUNCTION  tagbar#state#set_current_file()
    Defined: ~/.vim/plugged/tagbar/autoload/tagbar/state.vim line 5
Called 5 times
Total time:   0.000419
 Self time:   0.000228

count  total (s)   self (s)
    5   0.000412   0.000221     call s:get().setCurrentFile(a:fileinfo)

FUNCTION  airline#extensions#tabline#formatters#default#format()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/formatters/default.vim line 12
Called 12 times
Total time:   0.001792
 Self time:   0.001352

count  total (s)   self (s)
   12              0.000100   let fmod = get(g:, 'airline#extensions#tabline#fnamemod', ':~:.')
   12              0.000041   let _ = ''
                            
   12              0.000066   let name = bufname(a:bufnr)
   12              0.000047   if empty(name)
                                let _ .= '[No Name]'
   12              0.000138   elseif name =~ 'term://'
                                " Neovim Terminal
                                let _ = substitute(name, '\(term:\)//.*:\(.*\)', '\1 \2', '')
   12              0.000016   else
   12              0.000031     if s:fnamecollapse
                                  " Does not handle non-ascii characters like Cyrillic: 'D/Учёба/t.c'
                                  "let _ .= substitute(fnamemodify(name, fmod), '\v\w\zs.{-}\ze(\\|/)', '', 'g')
   12              0.000149       let _ .= pathshorten(fnamemodify(name, fmod))
                                else
                                  let _ .= fnamemodify(name, fmod)
   12              0.000014     endif
   12              0.000093     if a:bufnr != bufnr('%') && s:fnametruncate && strlen(_) > s:fnametruncate
                                  let _ = strpart(_, 0, s:fnametruncate)
   12              0.000011     endif
   12              0.000013   endif
                            
   12   0.000770   0.000329   return airline#extensions#tabline#formatters#default#wrap_name(a:bufnr, _)

FUNCTION  gitgutter#utility#shellescape()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim line 79
Called 27 times
Total time:   0.001953
 Self time:   0.001953

count  total (s)   self (s)
   27              0.001785   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
   27              0.000118     return a:arg
                              elseif s:winshell()
                                return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
                              else
                                return shellescape(a:arg)
                              endif

FUNCTION  airline#util#ignore_buf()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim line 136
Called 105 times
Total time:   0.003356
 Self time:   0.003356

count  total (s)   self (s)
  105              0.000847   let pat = '\c\v'. get(g:, 'airline#ignore_bufadd_pat', ''). get(g:, 'airline#extensions#tabline#ignore_bufadd_pat',  '!|defx|gundo|nerd_tree|startify|tagbar|term://|undotree|vimfiler')
  105              0.002418   return match(a:name, pat) > -1

FUNCTION  tagbar#currenttag()
    Defined: ~/.vim/plugged/tagbar/autoload/tagbar.vim line 3550
Called 13 times
Total time:   0.003097
 Self time:   0.000729

count  total (s)   self (s)
                                " Indicate that the statusline functionality is being used. This prevents
                                " the CloseWindow() function from removing the autocommands.
   13              0.000029     let s:statusline_in_use = 1
                            
   13              0.000015     if a:0 > 0
                                    " also test for non-zero value for backwards compatibility
   13              0.000087         let longsig   = a:1 =~# 's' || (type(a:1) == type(0) && a:1 != 0)
   13              0.000041         let fullpath  = a:1 =~# 'f'
   13              0.000032         let prototype = a:1 =~# 'p'
                                else
                                    let longsig   = 0
                                    let fullpath  = 0
                                    let prototype = 0
   13              0.000007     endif
                            
   13   0.000372   0.000086     if !s:Init(1)
                                    return a:default
   13              0.000005     endif
                            
   13   0.001973   0.000102     let tag = s:GetNearbyTag(0, 1)
                            
   13              0.000022     if !empty(tag)
   13              0.000014         if prototype
                                        return tag.getPrototype(1)
   13              0.000008         else
   13   0.000358   0.000146             return printf(a:fmt, tag.str(longsig, fullpath))
                                    endif
                                else
                                    return a:default
                                endif

FUNCTION  gitgutter#async#available()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim line 9
Called 9 times
Total time:   0.000070
 Self time:   0.000070

count  total (s)   self (s)
    9              0.000056   return s:available

FUNCTION  <SNR>163_is_branch_empty()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim line 22
Called 105 times
Total time:   0.000679
 Self time:   0.000679

count  total (s)   self (s)
  105              0.000617   return exists('*airline#extensions#branch#head') && empty(get(b:, 'airline_head', ''))

FUNCTION  WebDevIconsGetFileTypeSymbol()
    Defined: ~/.vim/plugged/vim-devicons/plugin/webdevicons.vim line 440
Called 117 times
Total time:   0.024987
 Self time:   0.023772

count  total (s)   self (s)
  117              0.000219   if a:0 == 0
  105              0.000412     let fileNodeExtension = expand('%:e')
  105              0.000275     let fileNode = expand('%:t')
  105              0.000154     let isDirectory = 0
   12              0.000014   else
   12              0.000082     let fileNodeExtension = fnamemodify(a:1, ':e')
   12              0.000093     let fileNode = fnamemodify(a:1, ':t')
   12              0.000035     if a:0 > 1
                                  let isDirectory = a:2
   12              0.000015     else
   12              0.000037       let isDirectory = 0
   12              0.000014     endif
  117              0.000063   endif
                            
  117              0.000291   if isDirectory == 0 || g:DevIconsEnableFolderPatternMatching
                            
  117              0.000344     let symbol = g:WebDevIconsUnicodeDecorateFileNodesDefaultSymbol
  117              0.000419     let fileNodeExtension = tolower(fileNodeExtension)
  117              0.000330     let fileNode = tolower(fileNode)
                            
 1170              0.003205     for [pattern, glyph] in items(g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols)
 1053              0.007314       if match(fileNode, pattern) != -1
                                    let symbol = glyph
                                    break
 1053              0.000517       endif
 1170              0.000718     endfor
                            
  117              0.000346     if symbol == g:WebDevIconsUnicodeDecorateFileNodesDefaultSymbol
  117              0.000507       if has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, fileNode)
                                    let symbol = g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[fileNode]
  117              0.000811       elseif ((isDirectory == 1 && g:DevIconsEnableFolderExtensionPatternMatching) || isDirectory == 0) && has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, fileNodeExtension)
                                    let symbol = g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[fileNodeExtension]
  117              0.000161       elseif isDirectory == 1
                                    let symbol = g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol
  117              0.000073       endif
  117              0.000071     endif
                            
                              else
                                let symbol = g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol
  117              0.000070   endif
                            
  117   0.002755   0.001540   let artifactFix = s:DevIconsGetArtifactFix()
                            
  117              0.000260   return symbol . artifactFix
                            

FUNCTION  <SNR>196_str()
    Defined: ~/.vim/plugged/tagbar/autoload/tagbar/prototypes/normaltag.vim line 32
Called 13 times
Total time:   0.000212
 Self time:   0.000212

count  total (s)   self (s)
   13              0.000024     if a:full && self.path !=# ''
                                    let str = self.path . self.typeinfo.sro . self.name
   13              0.000007     else
   13              0.000022         let str = self.name
   13              0.000007     endif
                            
   13              0.000032     if has_key(self.fields, 'signature')
                                    if a:longsig
                                        let str .= self.fields.signature
                                    else
                                        let str .= '()'
                                    endif
   13              0.000006     endif
                            
   13              0.000014     return str

FUNCTION  CocActionAsync()
    Defined: ~/.vim/plugged/coc.nvim/plugin/coc.vim line 24
Called 5 times
Total time:   0.001954
 Self time:   0.000175

count  total (s)   self (s)
    5   0.001945   0.000167   return s:AsyncRequest('CocAction', a:000)

FUNCTION  <SNR>116_get_matching_env()
    Defined: ~/.vim/plugged/vimtex/autoload/vimtex/delim.vim line 793
Called 15 times
Total time:   0.000709
 Self time:   0.000623

count  total (s)   self (s)
   15              0.000017   try
   15   0.000422   0.000336     let [lnum, cnum] = searchpairpos(self.re.open, '', self.re.close, self.gms_flags, '', 0, s:get_timeout())
                              catch /E118/
                                let [lnum, cnum] = searchpairpos(self.re.open, '', self.re.close, self.gms_flags, '', self.gms_stopline)
   15              0.000013   endtry
                            
   15              0.000132   let match = matchstr(getline(lnum), '^' . self.re.corr, cnum-1)
   15              0.000034   return [match, lnum, cnum]

FUNCTION  airline#parts#paste()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim line 63
Called 105 times
Total time:   0.000423
 Self time:   0.000423

count  total (s)   self (s)
  105              0.000371   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  <SNR>116_parser_delim_get_regexp()
    Defined: ~/.vim/plugged/vimtex/autoload/vimtex/delim.vim line 761
Called 90 times
Total time:   0.003127
 Self time:   0.003127

count  total (s)   self (s)
   90              0.000270   let l:type = a:0 > 0 ? a:1 : 'delim_all'
                            
                              " First check for unmatched math delimiter
   90              0.000134   if a:delim ==# '.'
                                return g:vimtex#delim#re.delim_math[a:side ? 'open' : 'close']
   90              0.000053   endif
                            
                              " Next check normal delimiters
   90              0.001841   let l:index = index(map(copy(g:vimtex#delim#lists[l:type].name),   'v:val[' . a:side . ']'), a:delim)
   90              0.000404   return l:index >= 0 ? g:vimtex#delim#lists[l:type].re[l:index][a:side] : ''

FUNCTION  airline#parts#readonly()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim line 89
Called 105 times
Total time:   0.005733
 Self time:   0.002377

count  total (s)   self (s)
                              " only consider regular buffers (e.g. ones that represent actual files,
                              " but not special ones like e.g. NERDTree)
  105   0.004622   0.001266   if !empty(&buftype) || airline#util#ignore_buf(bufname('%'))
                                return ''
  105              0.000069   endif
  105              0.000301   if &readonly && !filereadable(bufname('%'))
                                return '[noperm]'
  105              0.000088   else
  105              0.000241     return &readonly ? g:airline_symbols.readonly : ''
                              endif

FUNCTION  UltiSnips#TrackChange()
    Defined: ~/.vim/plugged/ultisnips/autoload/UltiSnips.vim line 151
Called 15 times
Total time:   0.076133
 Self time:   0.076123

count  total (s)   self (s)
   15   0.076114   0.076105     py3 UltiSnips_Manager._track_change()

FUNCTION  <SNR>181_on_stderr_nvim()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim line 63
Called 18 times
Total time:   0.000470
 Self time:   0.000147

count  total (s)   self (s)
   18              0.000039   if a:data != ['']  " With Neovim there is always [''] reported on stderr.
    9   0.000399   0.000076     call self.handler.err(self.buffer)
   18              0.000007   endif

FUNCTION  airline#highlighter#exec()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim line 104
Called 802 times
Total time:   0.166938
 Self time:   0.044435

count  total (s)   self (s)
  802              0.001046   if pumvisible()
                                return
  802              0.000322   endif
  802              0.001118   let colors = a:colors
  802              0.000806   if s:is_win32term
                                let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
  802              0.000316   endif
  802   0.085739   0.006315   let old_hi = airline#highlighter#get_highlight(a:group)
  802              0.001362   if len(colors) == 4
  352              0.000630     call add(colors, '')
  802              0.000318   endif
  802              0.000938   if g:airline_gui_mode ==# 'gui'
                                let new_hi = [colors[0], colors[1], '', '', colors[4]]
  802              0.000405   else
  802              0.004095     let new_hi = ['', '', printf("%s", colors[2]), printf("%s", colors[3]), colors[4]]
  802              0.000353   endif
  802   0.026609   0.005208   let colors = s:CheckDefined(colors)
  802   0.009139   0.004569   if old_hi != new_hi || !s:hl_group_exists(a:group)
  262   0.019125   0.002016     let cmd = printf('hi %s%s', a:group, s:GetHiCmd(colors))
  262              0.001426     exe cmd
  262              0.000616     if has_key(s:hl_groups, a:group)
  262              0.000545       let s:hl_groups[a:group] = colors
  262              0.000120     endif
  802              0.000297   endif

FUNCTION  <SNR>128_parse_args()
    Defined: ~/.vim/plugged/vimtex/autoload/vimtex/pos.vim line 67
Called 308 times
Total time:   0.007269
 Self time:   0.006766

count  total (s)   self (s)
                              "
                              " The arguments should be in one of the following forms (when unpacked):
                              "
                              "   [lnum, cnum]
                              "   [bufnum, lnum, cnum, ...]
                              "   {'lnum' : lnum, 'cnum' : cnum}
                              "
                            
  308              0.000909   if len(a:args) > 1
   15              0.000093     return s:parse_args([a:args])
  293              0.000565   elseif len(a:args) == 1
  293              0.000926     if type(a:args[0]) == type({})
   90              0.000394       return [get(a:args[0], 'lnum'), get(a:args[0], 'cnum')]
  203              0.000139     else
  203              0.000383       if len(a:args[0]) == 2
   15              0.000028         return a:args[0]
  188              0.000100       else
  188              0.000426         return a:args[0][1:]
                                  endif
                                endif
                              else
                                return a:args
                              endif

FUNCTION  <SNR>140_indent_tikz()
    Defined: ~/.vim/plugged/vimtex/indent/tex.vim line 283
Called 1 time
Total time:   0.000202
 Self time:   0.000088

count  total (s)   self (s)
    1              0.000012   if !has_key(b:vimtex.packages, 'tikz') | return 0 | endif
                            
    1   0.000137   0.000023   let l:env_pos = vimtex#env#is_inside('tikzpicture')
    1              0.000008   if l:env_pos[0] > 0 && l:env_pos[0] < a:lnum
                                let l:prev_starts = a:prev =~# s:tikz_commands
                                let l:prev_stops  = a:prev =~# ';\s*$'
                            
                                " Increase indent on tikz command start
                                if l:prev_starts && ! l:prev_stops
                                  return s:sw
                                endif
                            
                                " Decrease indent on tikz command end, i.e. on semicolon
                                if ! l:prev_starts && l:prev_stops
                                  let l:context = join(getline(l:env_pos[0], a:lnum-1), '')
                                  return -s:sw*(l:context =~# s:tikz_commands)
                                endif
    1              0.000001   endif
                            
    1              0.000002   return 0

FUNCTION  <SNR>162_get_syn()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim line 37
Called 3012 times
Total time:   0.059289
 Self time:   0.059289

count  total (s)   self (s)
 3012              0.006157   if !exists("g:airline_gui_mode")
                                let g:airline_gui_mode = airline#init#gui_mode()
 3012              0.001164   endif
 3012              0.002816   let color = ''
 3012              0.004913   if hlexists(a:group)
 3012              0.012080     let color = synIDattr(synIDtrans(hlID(a:group)), a:what, g:airline_gui_mode)
 3012              0.001277   endif
 3012              0.005146   if empty(color) || color == -1
                                " should always exists
                                let color = synIDattr(synIDtrans(hlID('Normal')), a:what, g:airline_gui_mode)
                                " however, just in case
                                if empty(color) || color == -1
                                  let color = 'NONE'
                                endif
 3012              0.001011   endif
 3012              0.002501   return color

FUNCTION  gitgutter#utility#setbufvar()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim line 9
Called 18 times
Total time:   0.000858
 Self time:   0.000858

count  total (s)   self (s)
   18              0.000123   let buffer = +a:buffer
                              " Default value for getbufvar() was introduced in Vim 7.3.831.
   18              0.000155   let bvars = getbufvar(buffer, '')
   18              0.000057   if empty(bvars)
                                let bvars = {}
   18              0.000020   endif
   18              0.000095   let dict = get(bvars, 'gitgutter', {})
   18              0.000074   let needs_setting = empty(dict)
   18              0.000101   let dict[a:varname] = a:val
   18              0.000035   if needs_setting
                                call setbufvar(buffer, 'gitgutter', dict)
   18              0.000016   endif

FUNCTION  <SNR>162_get_array()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim line 56
Called 1506 times
Total time:   0.010482
 Self time:   0.010482

count  total (s)   self (s)
 1506              0.004111   let opts=empty(a:opts) ? '' : join(a:opts, ',')
 1506              0.005854   return g:airline_gui_mode ==# 'gui' ? [ a:fg, a:bg, '', '', opts ] : [ '', '', a:fg, a:bg, opts ]

FUNCTION  airline#extensions#whitespace#check()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim line 62
Called 105 times
Total time:   0.021692
 Self time:   0.012526

count  total (s)   self (s)
  105              0.000427   let max_lines = get(g:, 'airline#extensions#whitespace#max_lines', 20000)
  105              0.000655   if &readonly || !&modifiable || !s:enabled || line('$') > max_lines || get(b:, 'airline_whitespace_disabled', 0)
                                return ''
  105              0.000056   endif
  105              0.000751   let skip_check_ft = extend(s:skip_check_ft, get(g:, 'airline#extensions#whitespace#skip_indent_check_ft', {}), 'force')
                            
  105              0.000301   if !exists('b:airline_whitespace_check')
    2              0.000011     let b:airline_whitespace_check = ''
    2              0.000039     let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))
                            
    2              0.000007     let trailing = 0
    2              0.000007     let check = 'trailing'
    2              0.000050     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    2              0.000005       try
    2              0.000018         let regexp = get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$')
    2              0.000057         let trailing = search(regexp, 'nw')
                                  catch
                                    call airline#util#warning(printf('Whitespace: error occurred evaluating "%s"', regexp))
                                    echomsg v:exception
                                    return ''
    2              0.000005       endtry
    2              0.000003     endif
                            
    2              0.000007     let mixed = 0
    2              0.000007     let check = 'indent'
    2              0.000043     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    2   0.003116   0.000047       let mixed = s:check_mixed_indent()
    2              0.000003     endif
                            
    2              0.000005     let mixed_file = ''
    2              0.000004     let check = 'mixed-indent-file'
    2              0.000026     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    2   0.000160   0.000031       let mixed_file = s:check_mixed_indent_file()
    2              0.000001     endif
                            
    2              0.000003     let long = 0
    2              0.000006     if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
    2              0.000001     endif
                            
    2              0.000003     let conflicts = 0
    2              0.000004     if index(checks, 'conflicts') > -1
    2   0.000432   0.000023       let conflicts = s:conflict_marker()
    2              0.000003     endif
                            
    2              0.000009     if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file) || conflicts != 0
    2              0.000006       let b:airline_whitespace_check = s:symbol
    2              0.000005       if strlen(s:symbol) > 0
    2              0.000006         let space = (g:airline_symbols.space)
                                  else
                                    let space = ''
    2              0.000001       endif
                            
    2              0.000003       if s:show_message
    2              0.000002         if trailing != 0
    2              0.000010           let trailing_fmt = get(g:, 'airline#extensions#whitespace#trailing_format', '[%s]trailing')
    2              0.000015           let b:airline_whitespace_check .= space.printf(trailing_fmt, trailing)
    2              0.000001         endif
    2              0.000003         if mixed != 0
                                      let mixed_indent_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_format', '[%s]mixed-indent')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_fmt, mixed)
    2              0.000001         endif
    2              0.000003         if long != 0
                                      let long_fmt = get(g:, 'airline#extensions#whitespace#long_format', '[%s]long')
                                      let b:airline_whitespace_check .= space.printf(long_fmt, long)
    2              0.000001         endif
    2              0.000005         if !empty(mixed_file)
                                      let mixed_indent_file_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_file_format', '[%s]mix-indent-file')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_file_fmt, mixed_file)
    2              0.000001         endif
    2              0.000003         if conflicts != 0
                                      let conflicts_fmt = get(g:, 'airline#extensions#whitespace#conflicts_format', '[%s]conflicts')
                                      let b:airline_whitespace_check .= space.printf(conflicts_fmt, conflicts)
    2              0.000001         endif
    2              0.000001       endif
    2              0.000001     endif
  105              0.000052   endif
  105   0.006510   0.000951   return airline#util#shorten(b:airline_whitespace_check, 120, 9)

FUNCTION  airline#extensions#tabline#formatters#default#wrap_name()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/formatters/default.vim line 38
Called 12 times
Total time:   0.000441
 Self time:   0.000441

count  total (s)   self (s)
   12              0.000087   let _ = s:buf_nr_show ? printf(s:buf_nr_format, a:bufnr) : ''
   12              0.000149   let _ .= substitute(a:buffer_name, '\\', '/', 'g')
                            
   12              0.000083   if getbufvar(a:bufnr, '&modified') == 1
   12              0.000050     let _ .= s:buf_modified_symbol
   12              0.000013   endif
   12              0.000026   return _

FUNCTION  <SNR>163_get_hunks_gitgutter()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim line 27
Called 105 times
Total time:   0.007349
 Self time:   0.002040

count  total (s)   self (s)
  105   0.001705   0.001025   if !get(g:, 'gitgutter_enabled', 0) || s:is_branch_empty()
                                return ''
  105              0.000055   endif
  105   0.005422   0.000791   return GitGutterGetHunkSummary()

FUNCTION  <SNR>162_exec_separator()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim line 189
Called 352 times
Total time:   0.139040
 Self time:   0.012605

count  total (s)   self (s)
  352              0.000507   if pumvisible()
                                return
  352              0.000123   endif
  352              0.000914   let group = a:from.'_to_'.a:to.a:suffix
  352   0.036104   0.002354   let l:from = airline#themes#get_highlight(a:from.a:suffix)
  352   0.034428   0.002443   let l:to = airline#themes#get_highlight(a:to.a:suffix)
  352              0.000323   if a:inverse
  128              0.000399     let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
  224              0.000091   else
  224              0.000705     let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
  352              0.000143   endif
  352              0.000838   let a:dict[group] = colors
  352   0.063204   0.002505   call airline#highlighter#exec(group, colors)

FUNCTION  <SNR>181_on_stdout_nvim()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim line 53
Called 9 times
Total time:   0.000086
 Self time:   0.000086

count  total (s)   self (s)
    9              0.000023   if empty(self.stdoutbuffer)
    9              0.000019     let self.stdoutbuffer = a:data
                              else
                                let self.stdoutbuffer = self.stdoutbuffer[:-2] + [self.stdoutbuffer[-1] . a:data[0]] + a:data[1:]
    9              0.000004   endif

FUNCTION  gitgutter#utility#repo_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim line 118
Called 9 times
Total time:   0.000702
 Self time:   0.000342

count  total (s)   self (s)
    9   0.000627   0.000267   let p = gitgutter#utility#getbufvar(a:bufnr, 'path', '')
    9              0.000064   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  <SNR>191_GetNearbyTag()
    Defined: ~/.vim/plugged/tagbar/autoload/tagbar.vim line 2927
Called 18 times
Total time:   0.003910
 Self time:   0.002925

count  total (s)   self (s)
   18              0.000042     if s:nearby_disabled
                                    return {}
   18              0.000013     endif
                            
   18   0.001166   0.000270     let fileinfo = tagbar#state#get_current_file(a:forcecurrent)
   18              0.000044     if empty(fileinfo)
                                    return {}
   18              0.000011     endif
                            
   18              0.000062     let typeinfo = fileinfo.typeinfo
   18              0.000030     if a:0 > 0
                                    let curline = a:1
   18              0.000015     else
   18              0.000058         let curline = line('.')
   18              0.000013     endif
   18              0.000033     let tag = {}
                            
                                " If a tag appears in a file more than once (for example namespaces in
                                " C++) only one of them has a 'tline' entry and can thus be highlighted.
                                " The only way to solve this would be to go over the whole tag list again,
                                " making everything slower. Since this should be a rare occurence and
                                " highlighting isn't /that/ important ignore it for now.
  137              0.000341     for line in range(curline, 1, -1)
  137              0.000412         if has_key(fileinfo.fline, line)
   18              0.000080             let curtag = fileinfo.fline[line]
   18   0.000247   0.000159             if a:all || typeinfo.getKind(curtag.fields.kind).stl
   18              0.000040                 let tag = curtag
   18              0.000017                 break
                                        endif
  119              0.000064         endif
  137              0.000131     endfor
                            
   18              0.000028     return tag

FUNCTION  <SNR>66_exists_file()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim line 207
Called 9 times
Total time:   0.001474
 Self time:   0.000381

count  total (s)   self (s)
    9   0.001466   0.000373   return filereadable(s:abs_path(a:bufnr, 0))

FUNCTION  <SNR>113_get_cmd_overlay()
    Defined: ~/.vim/plugged/vimtex/autoload/vimtex/cmd.vim line 406
Called 15 times
Total time:   0.000248
 Self time:   0.000248

count  total (s)   self (s)
   15              0.000129   let l:match = matchstr(getline(a:lnum), '^\s*[^>]*>', a:cnum)
                            
   15              0.000105   return empty(l:match) ? {} : {    'open' : {'lnum' : a:lnum, 'cnum' : a:cnum + 1},    'close' : {'lnum' : a:lnum, 'cnum' : a:cnum + strlen(l:match)},    'text' : l:match   }

FUNCTION  gitgutter#utility#windows()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim line 220
Called 9 times
Total time:   0.002913
 Self time:   0.002913

count  total (s)   self (s)
    9              0.002901   return has('win64') || has('win32') || has('win16')

FUNCTION  airline#parts#spell()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim line 67
Called 105 times
Total time:   0.002938
 Self time:   0.002938

count  total (s)   self (s)
  105              0.001303   let spelllang = g:airline_detect_spelllang ? printf(" [%s]", toupper(substitute(&spelllang, ',', '/', 'g'))) : ''
  105              0.000249   if g:airline_detect_spell && &spell
                                let winwidth = airline#util#winwidth()
                                if winwidth >= 90
                                  return g:airline_symbols.spell . spelllang
                                elseif winwidth >= 70
                                  return g:airline_symbols.spell
                                else
                                  return split(g:airline_symbols.spell, '\zs')[0]
                                endif
  105              0.000050   endif
  105              0.000090   return ''

FUNCTION  <SNR>140_clean_line()
    Defined: ~/.vim/plugged/vimtex/indent/tex.vim line 85
Called 2 times
Total time:   0.000058
 Self time:   0.000058

count  total (s)   self (s)
    2              0.000055   return substitute(a:line, '\s*\\\@<!%.*', '', '')

FUNCTION  WebDevIconsGetFileFormatSymbol()
    Defined: ~/.vim/plugged/vim-devicons/plugin/webdevicons.vim line 502
Called 105 times
Total time:   0.005493
 Self time:   0.004134

count  total (s)   self (s)
  105              0.000243   let fileformat = ''
  105              0.000132   let bomb = ''
                            
  105              0.000277   if (&bomb && g:WebDevIconsUnicodeByteOrderMarkerDefaultSymbol !=? '')
                                let bomb = g:WebDevIconsUnicodeByteOrderMarkerDefaultSymbol . ' '
  105              0.000059   endif
                            
  105              0.000204   if &fileformat ==? 'dos'
                                let fileformat = ''
  105              0.000164   elseif &fileformat ==? 'unix'
  105   0.001214   0.000676     if s:isDarwin()
                                  let fileformat = ''
  105              0.000063     else
  105              0.000146       let fileformat = ''
  105              0.000054     endif
                              elseif &fileformat ==? 'mac'
                                let fileformat = ''
  105              0.000057   endif
                            
  105   0.001725   0.000903   let artifactFix = s:DevIconsGetArtifactFix()
                            
  105              0.000272   return bomb . fileformat . artifactFix

FUNCTION  vimtex#pos#val()
    Defined: ~/.vim/plugged/vimtex/autoload/vimtex/pos.vim line 24
Called 30 times
Total time:   0.001094
 Self time:   0.000442

count  total (s)   self (s)
   30   0.000947   0.000295   let [l:lnum, l:cnum; l:rest] = s:parse_args(a:000)
                            
   30              0.000117   return 100000*l:lnum + min([l:cnum, 90000])

FUNCTION  coc#_complete()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc.vim line 57
Called 4 times
Total time:   0.002439
 Self time:   0.001124

count  total (s)   self (s)
    4              0.000023   let items = get(g:coc#_context, 'candidates', [])
    4              0.000014   let preselect = get(g:coc#_context, 'preselect', -1)
    4   0.002336   0.001021   call complete( g:coc#_context.start + 1, items)
    4              0.000027   if s:select_api && len(items) && preselect != -1
                                call nvim_select_popupmenu_item(preselect, v:false, v:false, {})
    4              0.000004   endif
    4              0.000006   return ''

FUNCTION  <SNR>140_is_verbatim()
    Defined: ~/.vim/plugged/vimtex/indent/tex.vim line 90
Called 2 times
Total time:   0.000526
 Self time:   0.000150

count  total (s)   self (s)
    2   0.000522   0.000146   return a:line !~# '\v\\%(begin|end)\{%(verbatim|lstlisting|minted)' && vimtex#env#is_inside('\%(lstlisting\|verbatim\|minted\)')[0]

FUNCTION  airline#parts#crypt()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim line 59
Called 105 times
Total time:   0.001219
 Self time:   0.001219

count  total (s)   self (s)
  105              0.001152   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  airline#extensions#keymap#status()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/keymap.vim line 10
Called 105 times
Total time:   0.001422
 Self time:   0.001422

count  total (s)   self (s)
  105              0.000697   if (get(g:, 'airline#extensions#keymap#enabled', 1) && has('keymap'))
  105              0.000629     return printf('%s', (!empty(&keymap) ? (g:airline_symbols.keymap . ' '. &keymap) : ''))
                              else
                                return ''
                              endif

FUNCTION  <SNR>22_on_cursor_moved()
    Defined: ~/.vim/plugged/vim-airline/plugin/airline.vim line 91
Called 12 times
Total time:   0.000855
 Self time:   0.000690

count  total (s)   self (s)
   12              0.000301   if winnr() != s:active_winnr || !exists('w:airline_active')
                                call s:on_window_changed('CursorMoved')
   12              0.000026   endif
   12   0.000423   0.000258   call airline#update_tabline()

FUNCTION  <SNR>191_HighlightTag()
    Defined: ~/.vim/plugged/tagbar/autoload/tagbar.vim line 2101
Called 5 times
Total time:   0.002455
 Self time:   0.000415

count  total (s)   self (s)
    5              0.000025     let tagline = 0
                            
    5              0.000037     let force = a:0 > 0 ? a:1 : 0
                            
    5              0.000017     if a:0 > 1
                                    let tag = s:GetNearbyTag(1, 0, a:2)
    5              0.000010     else
    5   0.002174   0.000133         let tag = s:GetNearbyTag(1, 0)
    5              0.000007     endif
    5              0.000021     if !empty(tag)
    5              0.000021         let tagline = tag.tline
    5              0.000006     endif
                            
                                " Don't highlight the tag again if it's the same one as last time.
                                " This prevents the Tagbar window from jumping back after scrolling with
                                " the mouse.
    5              0.000031     if !force && tagline ==# s:last_highlight_tline
    5              0.000010         return
                                else
                                    let s:last_highlight_tline = tagline
                                endif
                            
                                let tagbarwinnr = bufwinnr(s:TagbarBufName())
                                if tagbarwinnr == -1
                                    return
                                endif
                            
                                if tagbarwinnr == winnr()
                                    let in_tagbar = 1
                                else
                                    let in_tagbar = 0
                                    let prevwinnr = winnr()
                                    call s:goto_win('p', 1)
                                    let pprevwinnr = winnr()
                                    call s:goto_win(tagbarwinnr, 1)
                                endif
                            
                                try
                                    match none
                            
                                    " No tag above cursor position so don't do anything
                                    if tagline == 0
                                        return
                                    endif
                            
                                    if g:tagbar_autoshowtag == 1 || a:openfolds
                                        call s:OpenParents(tag)
                                    endif
                            
                                    " Check whether the tag is inside a closed fold and highlight the parent
                                    " instead in that case
                                    let tagline = tag.getClosedParentTline()
                            
                                    " Parent tag line number is invalid, better don't do anything
                                    if tagline <= 0
                                        return
                                    endif
                            
                                    " Go to the line containing the tag
                                    execute tagline
                            
                                    " Make sure the tag is visible in the window
                                    call winline()
                            
                                    let foldpat = '[' . g:tagbar#icon_open . g:tagbar#icon_closed . ' ]'
                                    let pattern = '/^\%' . tagline . 'l\s*' . foldpat . '[-+# ]\?\zs[^( ]\+\ze/'
                                    call tagbar#debug#log("Highlight pattern: '" . pattern . "'")
                                    if hlexists('TagbarHighlight') " Safeguard in case syntax highlighting is disabled
                                        execute 'match TagbarHighlight ' . pattern
                                    else
                                        execute 'match Search ' . pattern
                                    endif
                                finally
                                    if !in_tagbar
                                        call s:goto_win(pprevwinnr, 1)
                                        call s:goto_win(prevwinnr, 1)
                                    endif
                                    redraw
                                endtry

FUNCTION  <SNR>168_get_wordcount()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/wordcount.vim line 8
Called 7 times
Total time:   0.000407
 Self time:   0.000407

count  total (s)   self (s)
    7              0.000036     if get(g:, 'actual_curbuf', '') != bufnr('')
                                  return
    7              0.000003     endif
    7              0.000017     let query = a:visual_mode_active ? 'visual_words' : 'words'
    7              0.000338     return get(wordcount(), query, 0)

FUNCTION  vimtex#pos#get_cursor()
    Defined: ~/.vim/plugged/vimtex/autoload/vimtex/pos.vim line 12
Called 173 times
Total time:   0.001152
 Self time:   0.001152

count  total (s)   self (s)
  173              0.001070   return exists('*getcurpos') ? getcurpos() : getpos('.')

FUNCTION  <SNR>63_isDarwin()
    Defined: ~/.vim/plugged/vim-devicons/plugin/webdevicons.vim line 94
Called 105 times
Total time:   0.000538
 Self time:   0.000538

count  total (s)   self (s)
  105              0.000281   if exists('s:is_darwin')
  105              0.000147     return s:is_darwin
                              endif
                            
                              if exists('g:WebDevIconsOS')
                                let s:is_darwin = g:WebDevIconsOS ==? 'Darwin'
                                return s:is_darwin
                              endif
                            
                              if has('macunix')
                                let s:is_darwin = 1
                                return s:is_darwin
                              endif
                            
                              if ! has('unix')
                                let s:is_darwin = 0
                                return s:is_darwin
                              endif
                            
                              if system('uname -s') ==# "Darwin\n"
                                let s:is_darwin = 1
                              else
                                let s:is_darwin = 0
                              endif
                            
                              return s:is_darwin

FUNCTION  226()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim line 146
Called 10 times
Total time:   0.001131
 Self time:   0.001073

count  total (s)   self (s)
   10              0.000080     if exists('t:NERDTreeBufName')
                                    return bufwinnr(t:NERDTreeBufName)
   10              0.000013     endif
                            
                                " If WindowTree, there is no t:NERDTreeBufName variable. Search all windows.
   20              0.000168     for w in range(1,winnr('$'))
   10   0.000470   0.000413         if bufname(winbufnr(w)) =~# '^' . g:NERDTreeCreator.BufNamePrefix() . '\d\+$'
                                        return w
   10              0.000017         endif
   20              0.000064     endfor
                            
   10              0.000028     return -1

FUNCTION  227()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim line 162
Called 10 times
Total time:   0.001281
 Self time:   0.000151

count  total (s)   self (s)
   10   0.001273   0.000142     return s:NERDTree.GetWinNum() !=# -1

FUNCTION  GitGutterGetHunkSummary()
    Defined: ~/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim line 180
Called 105 times
Total time:   0.004630
 Self time:   0.001033

count  total (s)   self (s)
  105   0.004579   0.000982   return gitgutter#hunk#summary(winbufnr(0))

FUNCTION  airline#parts#mode()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim line 55
Called 105 times
Total time:   0.004763
 Self time:   0.001267

count  total (s)   self (s)
  105   0.004699   0.001203   return airline#util#shorten(get(w:, 'airline_current_mode', ''), 79, 1)

FUNCTION  UltiSnips#LeavingInsertMode()
    Defined: ~/.vim/plugged/ultisnips/autoload/UltiSnips.vim line 147
Called 7 times
Total time:   0.008596
 Self time:   0.008596

count  total (s)   self (s)
    7              0.008591     py3 UltiSnips_Manager._leaving_insert_mode()

FUNCTION  <SNR>180_setup_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim line 156
Called 9 times
Total time:   0.038472
 Self time:   0.001391

count  total (s)   self (s)
    9   0.001261   0.000269   if gitgutter#utility#has_repo_path(a:bufnr) | return | endif
                            
    9   0.037114   0.001026   return gitgutter#utility#set_repo_path(a:bufnr, a:continuation)

FUNCTION  <SNR>113_get_cmd()
    Defined: ~/.vim/plugged/vimtex/autoload/vimtex/cmd.vim line 314
Called 15 times
Total time:   0.043582
 Self time:   0.001946

count  total (s)   self (s)
   15   0.000651   0.000209   let [lnum, cnum, match] = s:get_cmd_name(a:direction ==# 'next')
   15              0.000056   if lnum == 0 | return {} | endif
                            
   15              0.000181   let res = { 'name' : match, 'text' : '', 'pos_start' : { 'lnum' : lnum, 'cnum' : cnum }, 'pos_end' : { 'lnum' : lnum, 'cnum' : cnum + strlen(match) - 1 }, 'args' : [],}
                            
                              " Environments always start with environment name and allows option
                              " afterwords
   15              0.000033   if res.name ==# '\begin'
   15   0.020267   0.000180     let arg = s:get_cmd_part('{', res.pos_end)
   15              0.000054     if empty(arg) | return res | endif
                            
   15              0.000043     call add(res.args, arg)
   15              0.000033     let res.pos_end.lnum = arg.close.lnum
   15              0.000022     let res.pos_end.cnum = arg.close.cnum
   15              0.000008   endif
                            
                              " Get overlay specification
   15   0.000398   0.000150   let res.overlay = s:get_cmd_overlay(res.pos_end.lnum, res.pos_end.cnum)
   15              0.000029   if !empty(res.overlay)
                                let res.pos_end.lnum = res.overlay.close.lnum
                                let res.pos_end.cnum = res.overlay.close.cnum
   15              0.000008   endif
                            
                              " Get options
   15   0.010338   0.000196   let res.opt = s:get_cmd_part('[', res.pos_end)
   15              0.000030   if !empty(res.opt)
                                let res.pos_end.lnum = res.opt.close.lnum
                                let res.pos_end.cnum = res.opt.close.cnum
   15              0.000009   endif
                            
                              " Get arguments
   15   0.010646   0.000205   let arg = s:get_cmd_part('{', res.pos_end)
   15              0.000027   while !empty(arg)
                                call add(res.args, arg)
                                let res.pos_end.lnum = arg.close.lnum
                                let res.pos_end.cnum = arg.close.cnum
                                let arg = s:get_cmd_part('{', res.pos_end)
   15              0.000012   endwhile
                            
                              " Include entire cmd text
   15   0.000414   0.000136   let res.text = s:text_between(res.pos_start, res.pos_end, 1)
                            
   15              0.000014   return res

FUNCTION  <SNR>66_is_file_buffer()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim line 69
Called 9 times
Total time:   0.000133
 Self time:   0.000133

count  total (s)   self (s)
    9              0.000123   return empty(getbufvar(a:bufnr, '&buftype'))

FUNCTION  <SNR>140_indent_conditionals()
    Defined: ~/.vim/plugged/vimtex/indent/tex.vim line 240
Called 1 time
Total time:   0.000134
 Self time:   0.000134

count  total (s)   self (s)
    1              0.000008   if !exists('s:re_cond')
                                let l:cfg = {}
                            
                                if exists('g:vimtex_indent_conditionals')
                                  let l:cfg = g:vimtex_indent_conditionals
                                  if empty(l:cfg)
                                    let s:re_cond = {}
                                    return 0
                                  endif
                                endif
                            
                                let s:re_cond = extend({ 'open': '\v(\\newif\s*)@<!\\if(f|field|name|numequal|thenelse)@!', 'else': '\\else\>', 'close': '\\fi\>',}, l:cfg)
    1              0.000002   endif
                            
    1              0.000008   if empty(s:re_cond) | return 0 | endif
                            
    1              0.000011   if get(s:, 'conditional_opened')
                                if a:line =~# s:re_cond.close
                                  silent! unlet s:conditional_opened
                                  return a:prev_line =~# s:re_cond.open ? 0 : -s:sw
                                elseif a:line =~# s:re_cond.else
                                  return -s:sw
                                elseif a:prev_line =~# s:re_cond.else
                                  return s:sw
                                elseif a:prev_line =~# s:re_cond.open
                                  return s:sw
                                endif
    1              0.000001   endif
                            
    1              0.000027   if a:line =~# s:re_cond.open && a:line !~# s:re_cond.close
                                let s:conditional_opened = 1
    1              0.000001   endif
                            
    1              0.000002   return 0

FUNCTION  gitgutter#async#execute()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim line 14
Called 9 times
Total time:   0.024191
 Self time:   0.023255

count  total (s)   self (s)
    9   0.001024   0.000213   call gitgutter#debug#log('[async] '.a:cmd)
                            
    9              0.000124   let options = {   'stdoutbuffer': [],   'buffer': a:bufnr,   'handler': a:handler }
    9   0.000357   0.000233   let command = s:build_command(a:cmd)
                            
    9              0.000060   if has('nvim')
    9              0.022008     call jobstart(command, extend(options, {   'on_stdout': function('s:on_stdout_nvim'),   'on_stderr': function('s:on_stderr_nvim'),   'on_exit':   function('s:on_exit_nvim') }))
                              else
                                call job_start(command, {   'out_cb':   function('s:on_stdout_vim', options),   'err_cb':   function('s:on_stderr_vim', options),   'close_cb': function('s:on_exit_vim', options) })
    9              0.000022   endif

FUNCTION  <SNR>168_update_wordcount()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/wordcount.vim line 66
Called 7 times
Total time:   0.000742
 Self time:   0.000143

count  total (s)   self (s)
    7   0.000465   0.000058   let wordcount = s:get_wordcount(0)
    7              0.000016   if wordcount != s:wordcount_cache || a:force_update
    4              0.000011     let s:wordcount_cache = wordcount
    4   0.000230   0.000037     let b:airline_wordcount =  s:format_wordcount(wordcount)
    7              0.000004   endif

FUNCTION  vimtex#env#is_inside()
    Defined: ~/.vim/plugged/vimtex/autoload/vimtex/env.vim line 107
Called 3 times
Total time:   0.000491
 Self time:   0.000491

count  total (s)   self (s)
    3              0.000040   let l:re_start = '\\begin\s*{' . a:env . '\*\?}'
    3              0.000028   let l:re_end = '\\end\s*{' . a:env . '\*\?}'
    3              0.000011   try
    3              0.000305     return searchpairpos(l:re_start, '', l:re_end, 'bnW', '', 0, 100)
                              catch /E118/
                                let l:stopline = max([line('.') - 500, 1])
                                return searchpairpos(l:re_start, '', l:re_end, 'bnW', '', l:stopline)
    3              0.000011   endtry

FUNCTION  454()
    Defined: ~/.vim/plugged/vimtex/autoload/vimtex/matchparen.vim line 63
Called 23 times
Total time:   0.000440
 Self time:   0.000440

count  total (s)   self (s)
   23              0.000201   silent! call matchdelete(w:vimtex_match_id1)
   23              0.000116   silent! call matchdelete(w:vimtex_match_id2)
   23              0.000065   unlet! w:vimtex_match_id1
   23              0.000032   unlet! w:vimtex_match_id2

FUNCTION  455()
    Defined: ~/.vim/plugged/vimtex/autoload/vimtex/matchparen.vim line 69
Called 23 times
Total time:   0.070954
 Self time:   0.002722

count  total (s)   self (s)
   23   0.000637   0.000196   call self.clear()
                            
   23   0.005784   0.000528   if vimtex#util#in_comment() | return | endif
                            
                              " This is a hack to ensure that $ in visual block mode adhers to the rule
                              " specified in :help v_$
   23              0.000110   if mode() ==# "\<c-v>"
                                let l:pos = vimtex#pos#get_cursor()
                                if len(l:pos) == 5 && l:pos[-1] == 2147483647
                                  call feedkeys('$', 'in')
                                endif
   23              0.000014   endif
                            
   23   0.052262   0.000343   let l:current = vimtex#delim#get_current('all', 'both')
   23              0.000073   if empty(l:current) | return | endif
                            
   15   0.010783   0.000167   let l:corresponding = vimtex#delim#get_matching(l:current)
   15              0.000040   if empty(l:corresponding) | return | endif
   15              0.000035   if empty(l:corresponding.match) | return | endif
                            
   15              0.000065   let [l:open, l:close] = l:current.is_open ? [l:current, l:corresponding] : [l:corresponding, l:current]
                            
   15              0.000029   if exists('*matchaddpos')
   15              0.000413     let w:vimtex_match_id1 = matchaddpos('MatchParen', [[l:open.lnum, l:open.cnum, strlen(l:open.match)]])
   15              0.000267     let w:vimtex_match_id2 = matchaddpos('MatchParen', [[l:close.lnum, l:close.cnum, strlen(l:close.match)]])
                              else
                                let w:vimtex_match_id1 = matchadd('MatchParen', '\%' . l:open.lnum . 'l\%' . l:open.cnum . 'c' . l:open.re.this)
                                let w:vimtex_match_id2 = matchadd('MatchParen', '\%' . l:close.lnum . 'l\%' . l:close.cnum . 'c' . l:close.re.this)
   15              0.000006   endif

FUNCTION  469()
    Defined: ~/.vim/plugged/vimtex/indent/tex.vim line 100
Called 1 time
Total time:   0.000192
 Self time:   0.000192

count  total (s)   self (s)
    1              0.000015   let self.finished = 0
    1              0.000005   let self.amp_ind = -1
    1              0.000003   let self.init_ind = -1
    1              0.000004   let self.prev_lnum = a:plnum
    1              0.000004   let self.prev_line = a:pline
    1              0.000012   let self.prev_ind = a:plnum > 0 ? indent(a:plnum) : 0
    1              0.000016   if !get(g:, 'vimtex_indent_on_ampersands', 1) | return self.prev_ind | endif
                            
    1              0.000050   if a:cline =~# self.re_align || a:cline =~# self.re_amp || a:cline =~# '^\v\s*\\%(end|])'
                                call self.parse_context(a:lnum, a:cline)
    1              0.000002   endif
                            
    1              0.000013   if a:cline =~# self.re_align
                                let self.finished = 1
                                let l:ind_diff =   strdisplaywidth(strpart(a:cline, 0, match(a:cline, self.re_amp))) - strdisplaywidth(strpart(a:cline, 0, match(a:cline, '\S')))
                                return self.amp_ind - l:ind_diff
    1              0.000001   endif
                            
    1              0.000008   if self.amp_ind >= 0 && (a:cline =~# '^\v\s*\\%(end|])' || a:cline =~# self.re_amp)
                                let self.prev_lnum = self.init_lnum
                                let self.prev_line = self.init_line
                                return self.init_ind
    1              0.000001   endif
                            
    1              0.000004   return self.prev_ind

FUNCTION  <SNR>116_parser_delim()
    Defined: ~/.vim/plugged/vimtex/autoload/vimtex/delim.vim line 662
Called 45 times
Total time:   0.013604
 Self time:   0.006698

count  total (s)   self (s)
   45              0.000097   let result = {}
   45              0.000101   let result.type = 'delim'
   45              0.001050   let result.side = a:match =~# g:vimtex#delim#re.delim_all.open ? 'open' : 'close'
   45              0.000128   let result.is_open = result.side ==# 'open'
   45              0.000227   let result.get_matching = function('s:get_matching_delim')
   45              0.000105   let result.gms_flags = result.is_open ? 'nW' : 'bnW'
   45              0.000271   let result.gms_stopline = result.is_open ? line('.') + g:vimtex_delim_stopline : max([1, line('.') - g:vimtex_delim_stopline])
                            
                              "
                              " Find corresponding delimiter and the regexps
                              "
   45              0.000675   if a:match =~# '^' . g:vimtex#delim#re.mods.both
                                let m1 = matchstr(a:match, '^' . g:vimtex#delim#re.mods.both)
                                let d1 = substitute(strpart(a:match, len(m1)), '^\s*', '', '')
                                let s1 = !result.is_open
                                let re1 = s:parser_delim_get_regexp(m1, s1, 'mods')  . '\s*' . s:parser_delim_get_regexp(d1, s1, 'delim_math')
                            
                                let m2 = s:parser_delim_get_corr(m1, 'mods')
                                let d2 = s:parser_delim_get_corr(d1, 'delim_math')
                                let s2 = result.is_open
                                let re2 = s:parser_delim_get_regexp(m2, s2, 'mods') . '\s*' . (m1 =~# '\\\%(left\|right\)'   ? '\%(' . s:parser_delim_get_regexp(d2, s2, 'delim_math') . '\|\.\)'   : s:parser_delim_get_regexp(d2, s2, 'delim_math'))
   45              0.000036   else
   45              0.000082     let d1 = a:match
   45              0.000050     let m1 = ''
   45   0.002330   0.000572     let re1 = s:parser_delim_get_regexp(a:match, !result.is_open)
                            
   45   0.004326   0.000546     let d2 = s:parser_delim_get_corr(a:match)
   45              0.000064     let m2 = ''
   45   0.001842   0.000473     let re2 = s:parser_delim_get_regexp(d2, result.is_open)
   45              0.000028   endif
                            
   45              0.000103   let result.delim = d1
   45              0.000106   let result.mod = m1
   45              0.000102   let result.corr = m2 . d2
   45              0.000073   let result.corr_delim = d2
   45              0.000079   let result.corr_mod = m2
   45              0.000301   let result.re = { 'this'  : re1, 'corr'  : re2, 'open'  : result.is_open ? re1 : re2, 'close' : result.is_open ? re2 : re1,}
                            
   45              0.000053   return result

FUNCTION  gitgutter#utility#is_active()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim line 56
Called 9 times
Total time:   0.004972
 Self time:   0.000878

count  total (s)   self (s)
    9   0.004958   0.000864   return g:gitgutter_enabled && gitgutter#utility#getbufvar(a:bufnr, 'enabled', 1) && !pumvisible() && s:is_file_buffer(a:bufnr) && s:exists_file(a:bufnr) && s:not_git_dir(a:bufnr)

FUNCTION  <SNR>191_do_delayed_update()
    Defined: ~/.vim/plugged/tagbar/autoload/tagbar.vim line 3311
Called 9 times
Total time:   0.002265
 Self time:   0.001050

count  total (s)   self (s)
    9   0.001690   0.000475     let curfile = tagbar#state#get_current_file(0)
    9              0.000056     if empty(curfile)
                                    let curfname = ''
    9              0.000018     else
    9              0.000056         let curfname = curfile.fpath
    9              0.000016     endif
                            
    9              0.000118     while !empty(s:delayed_update_files)
                                    let fname = remove(s:delayed_update_files, 0)
                                    let no_display = curfname !=# fname
                                    call s:AutoUpdate(fname, 1, no_display)
    9              0.000031     endwhile

FUNCTION  <SNR>63_CursorHoldUpdate()
    Defined: ~/.vim/plugged/vim-devicons/plugin/webdevicons.vim line 346
Called 5 times
Total time:   0.000726
 Self time:   0.000159

count  total (s)   self (s)
    5              0.000027   if g:NERDTreeUpdateOnCursorHold != 1
                                return
    5              0.000007   endif
                            
    5   0.000658   0.000091   if !exists('g:NERDTree') || !g:NERDTree.IsOpen()
    5              0.000009     return
                              endif
                            
                              " Do not update when a special buffer is selected
                              if !empty(&l:buftype)
                                return
                              endif
                            
                              " winnr need to make focus go to opened file
                              " CursorToTreeWin needed to avoid error on opening file
                              let l:winnr = winnr()
                              let l:altwinnr = winnr('#')
                            
                              call g:NERDTree.CursorToTreeWin()
                              call b:NERDTree.root.refreshFlags()
                              call NERDTreeRender()
                            
                              exec l:altwinnr . 'wincmd w'
                              exec l:winnr . 'wincmd w'

FUNCTION  airline#highlighter#get_highlight()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim line 67
Called 1506 times
Total time:   0.139179
 Self time:   0.069408

count  total (s)   self (s)
 1506              0.014851   let reverse = get(g:, 'airline_gui_mode', '') ==# 'gui' ? synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'gui') : synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')|| synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'term')
 1506              0.004199   if get(g:, 'airline_highlighting_cache', 0) && has_key(s:hl_groups, a:group)
                                let res = s:hl_groups[a:group]
                                return reverse ? [ res[1], res[0], res[3], res[2], res[4] ] : res
 1506              0.000794   else
 1506   0.039167   0.008404     let fg = s:get_syn(a:group, 'fg')
 1506   0.036322   0.007797     let bg = s:get_syn(a:group, 'bg')
 1506              0.004912     let bold = synIDattr(synIDtrans(hlID(a:group)), 'bold')
 1506              0.001251     if reverse
                                  let res = s:get_array(bg, fg, bold ? ['bold'] : a:000)
 1506              0.000760     else
 1506   0.020314   0.009832       let res = s:get_array(fg, bg, bold ? ['bold'] : a:000)
 1506              0.000707     endif
 1506              0.000575   endif
 1506              0.003952   let s:hl_groups[a:group] = res
 1506              0.001229   return res

FUNCTION  airline#extensions#coc#get_status()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/coc.vim line 45
Called 105 times
Total time:   0.004315
 Self time:   0.001225

count  total (s)   self (s)
                              " Shorten text for windows < 81 characters
  105   0.004169   0.001080   return airline#util#shorten(get(g:, 'coc_status', ''), 81, 9)

FUNCTION  airline#util#shorten()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim line 28
Called 315 times
Total time:   0.012144
 Self time:   0.008969

count  total (s)   self (s)
  315   0.008071   0.004895   if airline#util#winwidth() < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
  105              0.000209     if get(a:000, 0, 0)
                                  " shorten from tail
                                  return '…'.matchstr(a:text, '.\{'.a:minwidth.'}$')
  105              0.000070     else
                                  " shorten from beginning of string
  105              0.001031       return matchstr(a:text, '^.\{'.a:minwidth.'}').'…'
                                endif
  210              0.000108   else
  210              0.000263     return a:text
                              endif

FUNCTION  274()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim line 137
Called 9 times
Total time:   0.000323
 Self time:   0.000111

count  total (s)   self (s)
    9   0.000319   0.000107   call gitgutter#utility#setbufvar(a:buffer, 'path', -2)

FUNCTION  airline#highlighter#highlight_modified_inactive()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim line 229
Called 18 times
Total time:   0.009488
 Self time:   0.001105

count  total (s)   self (s)
   18              0.000107   if getbufvar(a:bufnr, '&modified')
   18              0.000295     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
                              else
                                let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
   18              0.000014   endif
                            
   18              0.000050   if !empty(colors)
   18   0.008842   0.000459     call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
   18              0.000012   endif

FUNCTION  <SNR>191_Init()
    Defined: ~/.vim/plugged/tagbar/autoload/tagbar.vim line 209
Called 13 times
Total time:   0.000286
 Self time:   0.000286

count  total (s)   self (s)
   13              0.000025     if s:checked_ctags == 2 && a:silent
                                    return 0
   13              0.000017     elseif s:checked_ctags != 1
                                    if !s:CheckForExCtags(a:silent)
                                        return 0
                                    endif
   13              0.000006     endif
                            
   13              0.000016     if !s:type_init_done
                                    call s:InitTypes()
   13              0.000006     endif
                            
   13              0.000016     if !s:autocommands_done
                                    call s:CreateAutocommands()
                                    call s:AutoUpdate(fnamemodify(expand('%'), ':p'), 0)
   13              0.000005     endif
                            
   13              0.000019     let s:init_done = 1
   13              0.000010     return 1

FUNCTION  VimtexIndentExpr()
    Defined: ~/.vim/plugged/vimtex/indent/tex.vim line 30
Called 1 time
Total time:   0.002498
 Self time:   0.000046

count  total (s)   self (s)
    1   0.002495   0.000043   return VimtexIndent(v:lnum)

FUNCTION  490()
    Defined: ~/.vim/plugged/tagbar/autoload/tagbar.vim line 777
Called 10 times
Total time:   0.000122
 Self time:   0.000122

count  total (s)   self (s)
   10              0.000114     return get(self._files, a:fname, {})

FUNCTION  492()
    Defined: ~/.vim/plugged/tagbar/autoload/tagbar.vim line 793
Called 5 times
Total time:   0.000065
 Self time:   0.000065

count  total (s)   self (s)
    5              0.000049     return has_key(self._files, a:fname)

FUNCTION  vimtex#delim#get_current()
    Defined: ~/.vim/plugged/vimtex/autoload/vimtex/delim.vim line 305
Called 23 times
Total time:   0.051919
 Self time:   0.000584

count  total (s)   self (s)
   23   0.051905   0.000570   return s:get_delim(extend({ 'direction' : 'current', 'type' : a:type, 'side' : a:side,}, get(a:, '1', {})))

FUNCTION  495()
    Defined: ~/.vim/plugged/tagbar/autoload/tagbar/state.vim line 32
Called 27 times
Total time:   0.000600
 Self time:   0.000487

count  total (s)   self (s)
   27   0.000490   0.000377     if !tagbar#is_paused() || a:force_current
   27              0.000076         return self._current
                                else
                                    return self._paused
                                endif

FUNCTION  496()
    Defined: ~/.vim/plugged/tagbar/autoload/tagbar/state.vim line 41
Called 5 times
Total time:   0.000060
 Self time:   0.000060

count  total (s)   self (s)
    5              0.000054     let self._current = a:fileinfo

FUNCTION  coc#rpc#notify()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/rpc.vim line 99
Called 74 times
Total time:   0.012322
 Self time:   0.002509

count  total (s)   self (s)
   74   0.001867   0.000855   if !coc#rpc#ready()
                                return ''
   74              0.000057   endif
   74   0.010062   0.001262   call s:client['notify'](a:method, a:args)
   74              0.000128   return ''

FUNCTION  <SNR>66_filename()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim line 203
Called 9 times
Total time:   0.001258
 Self time:   0.000282

count  total (s)   self (s)
    9   0.001248   0.000273   return fnamemodify(s:abs_path(a:bufnr, 0), ':t')

FUNCTION  airline#extensions#hunks#get_hunks()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim line 63
Called 105 times
Total time:   0.028562
 Self time:   0.012675

count  total (s)   self (s)
  105              0.000323   if !get(w:, 'airline_active', 0)
                                return ''
  105              0.000057   endif
                              " Cache values, so that it isn't called too often
  105   0.003186   0.002157   if exists("b:airline_hunks") && get(b:,  'airline_changenr', 0) == b:changedtick && airline#util#winwidth() == get(s:, 'airline_winwidth', 0) && get(b:, 'source_func', '') isnot# 's:get_hunks_signify' && get(b:, 'source_func', '') isnot# 's:get_hunks_gitgutter' && get(b:, 'source_func', '') isnot# 's:get_hunks_empty' && get(b:, 'source_func', '') isnot# 's:get_hunks_changes'
                                return b:airline_hunks
  105              0.000052   endif
  105   0.011772   0.001044   let hunks = airline#extensions#hunks#get_raw_hunks()
  105              0.000157   let string = ''
  105   0.001563   0.001049   let winwidth = get(airline#parts#get('hunks'), 'minwidth', 100)
  105              0.000207   if !empty(hunks)
  420              0.000702     for i in [0, 1, 2]
  315   0.005714   0.002923       if (s:non_zero_only == 0 && airline#util#winwidth() > winwidth) || hunks[i] > 0
                                    let string .= printf('%s%s ', s:hunk_symbols[i], hunks[i])
  315              0.000165       endif
  420              0.000337     endfor
  105              0.000061   endif
  105              0.000265   let b:airline_hunks = string
  105              0.000239   let b:airline_changenr = b:changedtick
  105   0.001584   0.000758   let s:airline_winwidth = airline#util#winwidth()
  105              0.000133   return string

FUNCTION  gitgutter#utility#getbufvar()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim line 24
Called 123 times
Total time:   0.002984
 Self time:   0.002984

count  total (s)   self (s)
  123              0.000672   let bvars = getbufvar(a:buffer, '')
  123              0.000306   if !empty(bvars)
  123              0.000557     let dict = get(bvars, 'gitgutter', {})
  123              0.000476     if has_key(dict, a:varname)
    9              0.000050       return dict[a:varname]
  114              0.000082     endif
  114              0.000072   endif
  114              0.000147   if a:0
  114              0.000158     return a:1
                              endif

FUNCTION  vimtex#cmd#get_at()
    Defined: ~/.vim/plugged/vimtex/autoload/vimtex/cmd.vim line 266
Called 15 times
Total time:   0.048093
 Self time:   0.000671

count  total (s)   self (s)
   15   0.000267   0.000157   let l:pos_saved = vimtex#pos#get_cursor()
   15   0.001136   0.000182   call call('vimtex#pos#set_cursor', a:000)
   15   0.046237   0.000206   let l:cmd = vimtex#cmd#get_current()
   15   0.000420   0.000093   call vimtex#pos#set_cursor(l:pos_saved)
   15              0.000015   return l:cmd

FUNCTION  airline#util#prepend()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim line 63
Called 420 times
Total time:   0.003399
 Self time:   0.003399

count  total (s)   self (s)
  420              0.001120   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
  420              0.000208   endif
  420              0.001487   return empty(a:text) ? '' : a:text.s:spc.g:airline_right_alt_sep.s:spc

FUNCTION  vimtex#cmd#get_current()
    Defined: ~/.vim/plugged/vimtex/autoload/vimtex/cmd.vim line 241
Called 15 times
Total time:   0.046031
 Self time:   0.000919

count  total (s)   self (s)
   15   0.000252   0.000148   let l:save_pos = vimtex#pos#get_cursor()
   15   0.000904   0.000175   let l:pos_val_cursor = vimtex#pos#val(l:save_pos)
                            
   15              0.000029   let l:depth = 3
   15              0.000034   while l:depth > 0
   15              0.000038     let l:depth -= 1
   15   0.043742   0.000160     let l:cmd = s:get_cmd('prev')
   15              0.000041     if empty(l:cmd) | break | endif
                            
   15   0.000474   0.000109     let l:pos_val = vimtex#pos#val(l:cmd.pos_end)
   15              0.000023     if l:pos_val >= l:pos_val_cursor
   15   0.000423   0.000091       call vimtex#pos#set_cursor(l:save_pos)
   15              0.000024       return l:cmd
                                else
                                  call vimtex#pos#set_cursor(vimtex#pos#prev(l:cmd.pos_start))
                                endif
                              endwhile
                            
                              call vimtex#pos#set_cursor(l:save_pos)
                            
                              return {}

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
  105   0.314730   0.016293  airline#check_mode()
   18   0.287862   0.046610  airline#highlighter#highlight()
  802   0.166938   0.044435  airline#highlighter#exec()
   38   0.161162             provider#python3#Call()
 1506   0.139179   0.069408  airline#highlighter#get_highlight()
  352   0.139040   0.012605  <SNR>162_exec_separator()
   68   0.078284   0.016901  <SNR>116_get_delim()
   16   0.077091             UltiSnips#CursorMoved()
   15   0.076133   0.076123  UltiSnips#TrackChange()
   23   0.070954   0.002722  455()
  704   0.065736   0.005980  airline#themes#get_highlight()
 3012   0.059289             <SNR>162_get_syn()
   23   0.051919   0.000584  vimtex#delim#get_current()
   15   0.048093   0.000671  vimtex#cmd#get_at()
   15   0.046031   0.000919  vimtex#cmd#get_current()
    9   0.044865   0.001421  gitgutter#process_buffer()
   15   0.043582   0.001946  <SNR>113_get_cmd()
   15   0.041823   0.001300  <SNR>116_parser_env()
   45   0.040669   0.002917  <SNR>113_get_cmd_part()
    9   0.038472   0.001391  <SNR>180_setup_path()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
   38              0.161162  provider#python3#Call()
   16              0.077091  UltiSnips#CursorMoved()
   15   0.076133   0.076123  UltiSnips#TrackChange()
 1506   0.139179   0.069408  airline#highlighter#get_highlight()
 3012              0.059289  <SNR>162_get_syn()
   18   0.287862   0.046610  airline#highlighter#highlight()
  802   0.166938   0.044435  airline#highlighter#exec()
  117   0.024987   0.023772  WebDevIconsGetFileTypeSymbol()
    9   0.024191   0.023255  gitgutter#async#execute()
  802              0.021401  <SNR>162_CheckDefined()
  262              0.017109  <SNR>162_GetHiCmd()
   68   0.078284   0.016901  <SNR>116_get_delim()
  105   0.314730   0.016293  airline#check_mode()
  105   0.028562   0.012675  airline#extensions#hunks#get_hunks()
  352   0.139040   0.012605  <SNR>162_exec_separator()
  105   0.021692   0.012526  airline#extensions#whitespace#check()
   22              0.012081  <SNR>74_Highlight_Matching_Pair()
 1506              0.010482  <SNR>162_get_array()
 1047              0.009744  airline#util#winwidth()
  315   0.012144   0.008969  airline#util#shorten()

